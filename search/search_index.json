{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"gosh - Go Shell A hybrid shell that combines Go's interpreter (via yaegi) with traditional command execution. Overview gosh is a hybrid shell that combines Go's interpreter (via yaegi) with traditional command execution. Cross-platform capable, designed as a daily driver, with instant startup and no PTY complexity. Core Philosophy Go-first : The shell is fundamentally a Go interpreter with shell conveniences No shell syntax parsing : We're not reimplementing bash. Bare commands work, everything else is Go Hybrid approach : ls just works, but files := $(ls) is also valid Instant startup : No waiting for REPLs to initialize Daily driver quality : Stable, fast, and pleasant to use Key Features Instant startup : No waiting for REPLs to initialize (looking at you, Swift) Multiline Go code : Write functions, if statements, for loops with proper continuation prompts Command substitution : $(command) syntax captures command output into Go strings Go REPL : Write Go code directly in your shell with persistent state Traditional commands : Just works - ls , git status , etc. Hybrid mode : Mix Go code and shell commands seamlessly Built-ins : cd , exit , pwd , help , init with path expansion Signal handling : Proper Ctrl+C behavior for interrupting processes Cross-platform : macOS & Linux support (Windows users can use PowerShell) Configuration support : Custom Go functions in ~/.config/gosh/config.go Quick Example # Regular shell commands work gosh> ls -la gosh> git status gosh> cd ~/projects # Go code just works gosh> x := 42 gosh> fmt.Println(x * 2) 84 gosh> func add(a, b int) int { ... return a + b ... } gosh> fmt.Println(add(5, 3)) 8 # Command substitution - game changing feature! gosh> files := $(ls) gosh> fmt.Println(strings.Split(files, \"\\n\")[0]) README.md # Mix and match gosh> pwd /Users/you/gosh gosh> name := \"gosh\" gosh> fmt.Printf(\"Welcome to %s\\n\", name) Welcome to gosh Status \u2705 MVP Complete : \u2705 Basic REPL loop with readline \u2705 Multiline Go code support (essential for Go!) \u2705 Go evaluation with yaegi and state persistence \u2705 Command execution with proper signal handling \u2705 Built-ins (cd, exit, pwd, help, init) \u2705 Command substitution $(command) syntax \u2705 Hybrid environment strategy (standard shell + Go extensions) \u2705 Smart routing between Go code and shell commands \u2705 Proper Ctrl+C interrupt handling \ud83c\udfaf Phase 2 Complete : \u2705 Hybrid environment system (standard shell configs + Go extensions) \u2705 Config file support (config.go) \u2705 Tab completion for commands and file paths \u2705 Color system with theme support \u2705 Comprehensive test coverage \u2705 Enhanced help system \ud83d\ude80 Phase 3 Complete : \u2705 Command history navigation (up/down arrows) \u2705 Better error messages with line numbers \u2705 Git integration in prompt \ud83d\udd27 Phase 4 Complete - Working Shellapi Functions : \u2705 Real Command Execution (v0.2.2) gosh v0.2.2 features shellapi functions that execute real commands via Go's os/exec , providing actual command output and persistent directory changes. Get Started Ready to dive in? Check out our Installation Guide to get gosh running on your system, then head to the Getting Started guide to learn the basics. For advanced usage and configuration, see the User Guide and CLI Reference . Note : gosh was built with passion for creating a better shell experience that combines the power of Go with the familiarity of traditional shell commands. Welcome to the future of shells! \ud83d\ude80","title":"gosh - Go Shell"},{"location":"#gosh-go-shell","text":"A hybrid shell that combines Go's interpreter (via yaegi) with traditional command execution.","title":"gosh - Go Shell"},{"location":"#overview","text":"gosh is a hybrid shell that combines Go's interpreter (via yaegi) with traditional command execution. Cross-platform capable, designed as a daily driver, with instant startup and no PTY complexity.","title":"Overview"},{"location":"#core-philosophy","text":"Go-first : The shell is fundamentally a Go interpreter with shell conveniences No shell syntax parsing : We're not reimplementing bash. Bare commands work, everything else is Go Hybrid approach : ls just works, but files := $(ls) is also valid Instant startup : No waiting for REPLs to initialize Daily driver quality : Stable, fast, and pleasant to use","title":"Core Philosophy"},{"location":"#key-features","text":"Instant startup : No waiting for REPLs to initialize (looking at you, Swift) Multiline Go code : Write functions, if statements, for loops with proper continuation prompts Command substitution : $(command) syntax captures command output into Go strings Go REPL : Write Go code directly in your shell with persistent state Traditional commands : Just works - ls , git status , etc. Hybrid mode : Mix Go code and shell commands seamlessly Built-ins : cd , exit , pwd , help , init with path expansion Signal handling : Proper Ctrl+C behavior for interrupting processes Cross-platform : macOS & Linux support (Windows users can use PowerShell) Configuration support : Custom Go functions in ~/.config/gosh/config.go","title":"Key Features"},{"location":"#quick-example","text":"# Regular shell commands work gosh> ls -la gosh> git status gosh> cd ~/projects # Go code just works gosh> x := 42 gosh> fmt.Println(x * 2) 84 gosh> func add(a, b int) int { ... return a + b ... } gosh> fmt.Println(add(5, 3)) 8 # Command substitution - game changing feature! gosh> files := $(ls) gosh> fmt.Println(strings.Split(files, \"\\n\")[0]) README.md # Mix and match gosh> pwd /Users/you/gosh gosh> name := \"gosh\" gosh> fmt.Printf(\"Welcome to %s\\n\", name) Welcome to gosh","title":"Quick Example"},{"location":"#status","text":"\u2705 MVP Complete : \u2705 Basic REPL loop with readline \u2705 Multiline Go code support (essential for Go!) \u2705 Go evaluation with yaegi and state persistence \u2705 Command execution with proper signal handling \u2705 Built-ins (cd, exit, pwd, help, init) \u2705 Command substitution $(command) syntax \u2705 Hybrid environment strategy (standard shell + Go extensions) \u2705 Smart routing between Go code and shell commands \u2705 Proper Ctrl+C interrupt handling \ud83c\udfaf Phase 2 Complete : \u2705 Hybrid environment system (standard shell configs + Go extensions) \u2705 Config file support (config.go) \u2705 Tab completion for commands and file paths \u2705 Color system with theme support \u2705 Comprehensive test coverage \u2705 Enhanced help system \ud83d\ude80 Phase 3 Complete : \u2705 Command history navigation (up/down arrows) \u2705 Better error messages with line numbers \u2705 Git integration in prompt \ud83d\udd27 Phase 4 Complete - Working Shellapi Functions : \u2705 Real Command Execution (v0.2.2) gosh v0.2.2 features shellapi functions that execute real commands via Go's os/exec , providing actual command output and persistent directory changes.","title":"Status"},{"location":"#get-started","text":"Ready to dive in? Check out our Installation Guide to get gosh running on your system, then head to the Getting Started guide to learn the basics. For advanced usage and configuration, see the User Guide and CLI Reference . Note : gosh was built with passion for creating a better shell experience that combines the power of Go with the familiarity of traditional shell commands. Welcome to the future of shells! \ud83d\ude80","title":"Get Started"},{"location":"config/","text":"Configuration Examples Discover practical configuration examples for common workflows, development environments, and productivity enhancers. Basic Setup Minimal Configuration Create ~/.config/gosh/config.go : package main import ( \"fmt\" \"os\" ) func init() { fmt.Println(\"\ud83d\ude80 gosh ready!\") } // Basic info function func info() { fmt.Printf(\"gosh v%s\\n\", \"main\".GetVersion()) fmt.Printf(\"User: %s\\n\", os.Getenv(\"USER\")) fmt.Printf(\"Home: %s\\n\", os.Getenv(\"HOME\")) } Development Workflows Go Developer Configuration package main import ( \"fmt\" \"os\" \"github.com/rsarv3006/gosh_lib/shellapi\" ) func init() { fmt.Println(\"\ud83d\udd27 Go developer environment loaded!\") } // Project navigation func goProject() string { return cdPath(\"~/go/src/github.com/yourname\") } func goSite() string { return cdPath(\"~/go/src/github.com/yourname/website\") } // Development workflow func buildAndTest() string { msg := \"Building and testing...\\n\" // Build if build, err := shellapi.GoBuild(); err != nil { return shellapi.ErrorMsg(\"Build Failed\", err.Error()) } else { msg += build } // Test if test, err := shellapi.GoTest(); err != nil { return shellapi.ErrorMsg(\"Tests Failed\", err.Error()) } else { msg += test } return shellapi.SuccessMsg(\"Complete\", \"Build and test successful\") } // Coverage and linting func check() string { msg := \"Running checks...\\n\" // Test coverage coverage, err := shellapi.RunShell(\"go\", \"test\", \"-cover\") if err != nil { msg += shellapi.ErrorMsg(\"Coverage\", err.Error()) } else { msg += shellapi.SuccessMsg(\"Coverage\", \"Tests passed\") } // Vet vet, err := shellapi.GoVet() if err != nil { msg += shellapi.ErrorMsg(\"Vet\", err.Error()) } else { msg += shellapi.SuccessMsg(\"Vet\", \"Code passes analysis\") } return msg } // Quick git operations func quickCommit(msg string) string { // Check status status, _ := shellapi.GitStatus() if status == \"\" { return \"Nothing to commit\" } // Add all shellapi.GitAdd(\".\") // Commit if _, err := shellapi.GitCommit(msg); err != nil { return shellapi.Error(\"Commit failed: \" + err.Error()) } return shellapi.Success(\"\u2713 Committed: \" + msg) } // Helper function for directory changes func cdPath(path string) string { result, err := shellapi.RunShell(\"cd\", path) if err != nil { return shellapi.ErrorMsg(\"CD Error\", err.Error()) } return result } Web Developer Configuration package main import ( \"fmt\" \"github.com/rsarv3006/gosh_lib/shellapi\" ) func init() { fmt.Println(\"\ud83c\udf10 Web developer environment loaded!\") } // Project workspaces func goReact() string { return cdPath(\"~/projects/react-app\") } func goVue() string { return cdPath(\"~/projects/vue-app\") } func goNext() string { return cdPath(\"~/projects/nextjs-app\") } // Package management func devSetup() string { msg := \"Setting up development environment...\\n\" // npm install if install, err := shellapi.NpmInstall(); err != nil { msg += shellapi.ErrorMsg(\"npm install\", err.Error()) } else { msg += shellapi.SuccessMsg(\"Dependencies\", \"npm install completed\") } return msg } // Development servers func startDev() string { return shellapi.NpmRun(\"dev\") } func startBuild() string { return shellapi.NpmRun(\"build\") } func startTest() string { return shellapi.NpmRun(\"test\") } // Docker workflow func dockerDev() string { msg := \"Starting development containers...\\n\" // Build and run dev containers if _, err := shellapi.RunShell(\"docker-compose\", \"up\", \"-d\", \"--build\"); err != nil { return shellapi.ErrorMsg(\"Docker\", err.Error()) } return shellapi.SuccessMsg(\"Docker\", \"Development containers started\") } func dockerStop() string { if _, err := shellapi.RunShell(\"docker-compose\", \"down\"); err != nil { return shellapi.ErrorMsg(\"Docker\", err.Error()) } return shellapi.Success(\"\ud83d\uded1 Docker containers stopped\") } DevOps/Cloud Engineer Configuration package main import ( \"fmt\" \"github.com/rsarv3006/gosh_lib/shellapi\" ) func init() { fmt.Println(\"\u2601\ufe0f DevOps environment loaded!\") } // Kubernetes operations func k8sPods() string { pods, err := shellapi.KubectlPods() if err != nil { return shellapi.ErrorMsg(\"K8s\", err.Error()) } return shellapi.InfoMsg(\"Pods\", pods) } func k8sLogs(app string) string { logs, err := shellapi.KubectlPods() if err != nil { return shellapi.ErrorMsg(\"K8s\", err.Error()) } // Get first pod in deployment podName := firstPod(app) if podName == \"\" { return shellapi.WarningMsg(\"Pod\", \"No pod found for \" + app) } podLogs, err := shellapi.KubectlLogs(podName) if err != nil { return shellapi.ErrorMsg(\"Logs\", err.Error()) } return shellapi.InfoMsg(app+\" Logs\", podLogs) } // Terraform workflows func tfInit() string { result, err := shellapi.RunShell(\"terraform\", \"init\") if err != nil { return shellapi.ErrorMsg(\"Terraform\", err.Error()) } return shellapi.SuccessMsg(\"Terraform\", \"Initialized\") } func tfPlan() string { result, err := shellapi.RunShell(\"terraform\", \"plan\") if err != nil { return shellapi.ErrorMsg(\"Terraform\", err.Error()) } return shellapi.InfoMsg(\"Terraform Plan\", result) } func tfApply() string { fmt.Println(shellapi.Warning(\"\u26a0\ufe0f This will apply changes to infrastructure\")) // In real implementation, add confirmation prompt result, err := shellapi.RunShell(\"terraform\", \"apply\", \"-auto-approve\") if err != nil { return shellapi.ErrorMsg(\"Terraform\", err.Error()) } return shellapi.SuccessMsg(\"Terraform\", \"Applied changes\") } // AWS CLI helpers func awsRegions() string { regions, err := shellapi.RunShell(\"aws\", \"ec2\", \"describe-regions\", \"--output\", \"table\") if err != nil { return shellapi.ErrorMsg(\"AWS\", err.Error()) } return shellapi.InfoMsg(\"AWS Regions\", regions) } func awsS3List() string { buckets, err := shellapi.RunShell(\"aws\", \"s3\", \"ls\") if err != nil { return shellapi.ErrorMsg(\"AWS S3\", err.Error()) } return shellapi.InfoMsg(\"S3 Buckets\", buckets) } // Helper functions func firstPod(app string) string { pods, err := shellapi.RunShell(\"kubectl\", \"get\", \"pods\", \"-l\", \"app=\"+app, \"-o\", \"jsonpath='{.items[0].metadata.name}'\") if err != nil { return \"\" } // Remove quotes and return return strings.ReplaceAll(pods, \"'\", \"\") } Project Management Multi-Project Workspace package main import ( \"fmt\" \"github.com/rsarv3006/gosh_lib/shellapi\" ) func init() { fmt.Println(\"\ud83d\udcc1 Multi-project workspace loaded!\") } // Project categories func goClient() string { return cdPath(\"~/projects/client-portal\") } func goApi() string { return cdPath(\"~/projects/api-server\") } func goAdmin() string { return cdPath(\"~/projects/admin-dashboard\") } // Environment switching func envDev() string { os.Setenv(\"NODE_ENV\", \"development\") os.Setenv(\"API_URL\", \"http://localhost:3000\") return shellapi.SuccessMsg(\"Environment\", \"Switched to development\") } func envStaging() string { os.Setenv(\"NODE_ENV\", \"staging\") os.Setenv(\"API_URL\", \"https://staging-api.example.com\") return shellapi.SuccessMsg(\"Environment\", \"Switched to staging\") } func envProd() string { os.Setenv(\"NODE_ENV\", \"production\") os.Setenv(\"API_URL\", \"https://api.example.com\") return shellapi.SuccessMsg(\"Environment\", \"Switched to production\") } // Project health check func projectHealth() string { msg := \"Project Health Report:\\n\" // Git status if gitStatus, err := shellapi.GitStatus(); err == nil { if gitStatus == \"\" { msg += shellapi.Success(\"\u2713 Git: Working tree clean\\n\") } else { msg += shellapi.Warning(\"\u26a0 Git: Uncommitted changes\\n\") } } // Dependencies if _, err := shellapi.NpmRun(\"test:dependencies\"); err != nil { msg += shellapi.Error(\"\u2717 Dependencies: Issues detected\\n\") } else { msg += shellapi.Success(\"\u2713 Dependencies: OK\\n\") } // Build status if _, err := shellapi.NpmRun(\"build:test\"); err != nil { msg += shellapi.Error(\"\u2717 Build: Failed\\n\") } else { msg += shellapi.Success(\"\u2713 Build: OK\\n\") } return msg } // Database operations func dbConnect() string { // Load environment dbUrl := os.Getenv(\"DATABASE_URL\") if dbUrl == \"\" { return shellapi.ErrorMsg(\"Database\", \"DATABASE_URL not set\") } // Test connection if _, err := shellapi.RunShell(\"pg_isready\", \"-d\", dbUrl); err != nil { return shellapi.ErrorMsg(\"Database\", \"Connection failed\") } return shellapi.SuccessMsg(\"Database\", \"Connected\") } func dbMigrate() string { msg := \"Running database migrations...\\n\" if migrate, err := shellapi.RunShell(\"npm\", \"run\", \"db:migrate\"); err != nil { return shellapi.ErrorMsg(\"Migration\", err.Error()) } return shellapi.SuccessMsg(\"Migration\", \"Completed\") + \"\\n\" + migrate } func dbSeed() string { msg := \"Seeding database...\\n\" if seed, err := shellapi.RunShell(\"npm\", \"run\", \"db:seed\"); err != nil { return shellapi.ErrorMsg(\"Seeding\", err.Error()) } return shellapi.SuccessMsg(\"Seeding\", \"Completed\") + \"\\n\" + seed } Productivity Enhancers System Information and Monitoring package main import ( \"fmt\" \"github.com/rsarv3006/gosh_lib/shellapi\" ) func init() { fmt.Println(\"\ud83d\udcca System monitoring loaded!\") } // System info func sysInfo() string { info := shellapi.Bold(\"System Information:\\n\") if uptime, err := shellapi.Uptime(); err == nil { info += shellapi.Bold(\"Uptime: \") + uptime + \"\\n\" } if user, err := shellapi.Whoami(); err == nil { info += shellapi.Bold(\"User: \") + user + \"\\n\" } if hostname, err := shellapi.Hostname(); err == nil { info += shellapi.Bold(\"Host: \") + hostname + \"\\n\" } if arch, err := shellapi.Arch(); err == nil { info += shellapi.Bold(\"Arch: \") + arch + \"\\n\" } return info } // Memory and disk usage func sysUsage() string { msg := shellapi.Bold(\"System Usage:\\n\") if mem, err := shellapi.Free(); err == nil { msg += shellapi.Bold(\"Memory:\\n\") + mem + \"\\n\" } if disk, err := shellapi.Df(); err == nil { msg += shellapi.Bold(\"Disk:\\n\") + disk + \"\\n\" } return msg } // Process monitoring func psGrep(pattern string) string { if pattern == \"\" { return \"Usage: psGrep <pattern>\" } result, err := shellapi.RunShell(\"ps\", \"aux\", \"|\", \"grep\", pattern) if err != nil { return shellapi.ErrorMsg(\"Process search\", err.Error()) } return shellapi.InfoMsg(\"Processes matching \"+pattern, result) } func portsUsed() string { result, err := shellapi.RunShell(\"lsof\", \"-i\", \"-n\", \"-P\") if err != nil { return shellapi.ErrorMsg(\"Ports\", err.Error()) } return shellapi.InfoMsg(\"Used Ports\", result) } File Management Tools package main import ( \"fmt\" \"github.com/rsarv3006/gosh_lib/shellapi\" ) func init() { fmt.Println(\"\ud83d\udcc2 File management tools loaded!\") } // Quick file operations func findLarge() string { result, err := shellapi.RunShell(\"find\", \".\", \"-type\", \"f\", \"-size\", \"+10M\", \"-exec\", \"ls\", \"-lh\", \"{}\", \";\") if err != nil { return shellapi.ErrorMsg(\"Find\", err.Error()) } return shellapi.InfoMsg(\"Large files (>10MB)\", result) } func findRecent(days int) string { if days <= 0 { days = 7 // default to 7 days } result, err := shellapi.RunShell(\"find\", \".\", \"-type\", \"f\", \"-mtime\", fmt.Sprintf(\"-%d\", days), \"-exec\", \"ls\", \"-lt\", \"{}\", \";\") if err != nil { return shellapi.ErrorMsg(\"Find\", err.Error()) } return shellapi.InfoMsg(fmt.Sprintf(\"Recent files (%d days)\", days), result) } func cleanTemp() string { msg := \"Cleaning temporary files...\\n\" // Remove common temp patterns patterns := []string{\"*~\", \"*.tmp\", \"*.swp\", \"*.bak\"} for _, pattern := range patterns { if result, err := shellapi.RunShell(\"find\", \".\", \"-name\", pattern, \"-delete\"); err == nil { if result == \"\" { msg += shellapi.Success(\"\u2713 Cleaned \" + pattern + \" files\\n\") } } } return shellapi.SuccessMsg(\"Cleanup\", \"Completed\") } // Project structure tools func treeFiles() string { result, err := shellapi.Tree() if err != nil { return shellapi.ErrorMsg(\"Tree\", err.Error()) } return result } func countByType(fileType string) string { if fileType == \"\" { return \"Usage: countByType <extension>\" } if !strings.HasPrefix(fileType, \".\") { fileType = \".\" + fileType } result, err := shellapi.RunShell(\"find\", \".\", \"-name\", \"*\"+fileType, \"|\", \"wc\", \"-l\") if err != nil { return shellapi.ErrorMsg(\"Count\", err.Error()) } count := strings.TrimSpace(result) return shellapi.InfoMsg(fileType+\" files\", count) } Environment-Specific Configs Container Development package main import ( \"github.com/rsarv3006/gosh_lib/shellapi\" ) func init() { fmt.Println(\"\ud83d\udc33 Container development loaded!\") } // Docker utilities func dockerClean() string { msg := \"Cleaning Docker resources...\\n\" // Remove stopped containers if _, err := shellapi.RunShell(\"docker\", \"container\", \"prune\", \"-f\"); err == nil { msg += shellapi.Success(\"\u2713 Removed stopped containers\\n\") } // Remove unused images if _, err := shellapi.RunShell(\"docker\", \"image\", \"prune\", \"-f\"); err == nil { msg += shellapi.Success(\"\u2713 Removed unused images\\n\") } // Remove unused volumes if _, err := shellapi.RunShell(\"docker\", \"volume\", \"prune\", \"-f\"); err == nil { msg += shellapi.Success(\"\u2713 Removed unused volumes\\n\") } return shellapi.SuccessMsg(\"Docker\", \"Cleanup completed\") } func dockerLogs(container string) string { if logs, err := shellapi.DockerLogs(container); err == nil { return shellapi.InfoMsg(container+\" logs\", logs) } else { return shellapi.ErrorMsg(\"Docker\", err.Error()) } } func dockerStats() string { result, err := shellapi.RunShell(\"docker\", \"stats\", \"--no-stream\") if err != nil { return shellapi.ErrorMsg(\"Docker\", err.Error()) } return shellapi.InfoMsg(\"Container Stats\", result) } Usage Examples After creating your config.go , access functions like this: # Development workflow gosh> buildAndTest() # Execute Go build and test gosh> quickCommit(\"fix bug\") # Quick commit with message gosh> projectHealth() # Check overall project status # Environment switching gosh> envStaging() # Switch to staging environment gosh> goApi() # Navigate to API project gosh> dbMigrate() # Run database migrations # System utilities gosh> sysInfo() # Show system information gosh> cleanTemp() # Clean temporary files gosh> findRecent(7) # Find files changed in last 7 days # Docker operations gosh> dockerClean() # Clean Docker resources gosh> dockerLogs(\"web\") # Show logs for web container Best Practices Start simple : Begin with basic functions and expand as needed Group related functions : Use prefixes like go* , db* , docker* Add error handling : Always check for errors and provide feedback Use color functions : Make output more readable with Success() , Error() , etc. Document your functions : Add comments explaining what each function does Test your configs : Reload gosh and test functions before relying on them Ready for the complete reference? Check out our CLI Reference for all available commands and shellapi functions!","title":"Configuration Examples"},{"location":"config/#configuration-examples","text":"Discover practical configuration examples for common workflows, development environments, and productivity enhancers.","title":"Configuration Examples"},{"location":"config/#basic-setup","text":"","title":"Basic Setup"},{"location":"config/#minimal-configuration","text":"Create ~/.config/gosh/config.go : package main import ( \"fmt\" \"os\" ) func init() { fmt.Println(\"\ud83d\ude80 gosh ready!\") } // Basic info function func info() { fmt.Printf(\"gosh v%s\\n\", \"main\".GetVersion()) fmt.Printf(\"User: %s\\n\", os.Getenv(\"USER\")) fmt.Printf(\"Home: %s\\n\", os.Getenv(\"HOME\")) }","title":"Minimal Configuration"},{"location":"config/#development-workflows","text":"","title":"Development Workflows"},{"location":"config/#go-developer-configuration","text":"package main import ( \"fmt\" \"os\" \"github.com/rsarv3006/gosh_lib/shellapi\" ) func init() { fmt.Println(\"\ud83d\udd27 Go developer environment loaded!\") } // Project navigation func goProject() string { return cdPath(\"~/go/src/github.com/yourname\") } func goSite() string { return cdPath(\"~/go/src/github.com/yourname/website\") } // Development workflow func buildAndTest() string { msg := \"Building and testing...\\n\" // Build if build, err := shellapi.GoBuild(); err != nil { return shellapi.ErrorMsg(\"Build Failed\", err.Error()) } else { msg += build } // Test if test, err := shellapi.GoTest(); err != nil { return shellapi.ErrorMsg(\"Tests Failed\", err.Error()) } else { msg += test } return shellapi.SuccessMsg(\"Complete\", \"Build and test successful\") } // Coverage and linting func check() string { msg := \"Running checks...\\n\" // Test coverage coverage, err := shellapi.RunShell(\"go\", \"test\", \"-cover\") if err != nil { msg += shellapi.ErrorMsg(\"Coverage\", err.Error()) } else { msg += shellapi.SuccessMsg(\"Coverage\", \"Tests passed\") } // Vet vet, err := shellapi.GoVet() if err != nil { msg += shellapi.ErrorMsg(\"Vet\", err.Error()) } else { msg += shellapi.SuccessMsg(\"Vet\", \"Code passes analysis\") } return msg } // Quick git operations func quickCommit(msg string) string { // Check status status, _ := shellapi.GitStatus() if status == \"\" { return \"Nothing to commit\" } // Add all shellapi.GitAdd(\".\") // Commit if _, err := shellapi.GitCommit(msg); err != nil { return shellapi.Error(\"Commit failed: \" + err.Error()) } return shellapi.Success(\"\u2713 Committed: \" + msg) } // Helper function for directory changes func cdPath(path string) string { result, err := shellapi.RunShell(\"cd\", path) if err != nil { return shellapi.ErrorMsg(\"CD Error\", err.Error()) } return result }","title":"Go Developer Configuration"},{"location":"config/#web-developer-configuration","text":"package main import ( \"fmt\" \"github.com/rsarv3006/gosh_lib/shellapi\" ) func init() { fmt.Println(\"\ud83c\udf10 Web developer environment loaded!\") } // Project workspaces func goReact() string { return cdPath(\"~/projects/react-app\") } func goVue() string { return cdPath(\"~/projects/vue-app\") } func goNext() string { return cdPath(\"~/projects/nextjs-app\") } // Package management func devSetup() string { msg := \"Setting up development environment...\\n\" // npm install if install, err := shellapi.NpmInstall(); err != nil { msg += shellapi.ErrorMsg(\"npm install\", err.Error()) } else { msg += shellapi.SuccessMsg(\"Dependencies\", \"npm install completed\") } return msg } // Development servers func startDev() string { return shellapi.NpmRun(\"dev\") } func startBuild() string { return shellapi.NpmRun(\"build\") } func startTest() string { return shellapi.NpmRun(\"test\") } // Docker workflow func dockerDev() string { msg := \"Starting development containers...\\n\" // Build and run dev containers if _, err := shellapi.RunShell(\"docker-compose\", \"up\", \"-d\", \"--build\"); err != nil { return shellapi.ErrorMsg(\"Docker\", err.Error()) } return shellapi.SuccessMsg(\"Docker\", \"Development containers started\") } func dockerStop() string { if _, err := shellapi.RunShell(\"docker-compose\", \"down\"); err != nil { return shellapi.ErrorMsg(\"Docker\", err.Error()) } return shellapi.Success(\"\ud83d\uded1 Docker containers stopped\") }","title":"Web Developer Configuration"},{"location":"config/#devopscloud-engineer-configuration","text":"package main import ( \"fmt\" \"github.com/rsarv3006/gosh_lib/shellapi\" ) func init() { fmt.Println(\"\u2601\ufe0f DevOps environment loaded!\") } // Kubernetes operations func k8sPods() string { pods, err := shellapi.KubectlPods() if err != nil { return shellapi.ErrorMsg(\"K8s\", err.Error()) } return shellapi.InfoMsg(\"Pods\", pods) } func k8sLogs(app string) string { logs, err := shellapi.KubectlPods() if err != nil { return shellapi.ErrorMsg(\"K8s\", err.Error()) } // Get first pod in deployment podName := firstPod(app) if podName == \"\" { return shellapi.WarningMsg(\"Pod\", \"No pod found for \" + app) } podLogs, err := shellapi.KubectlLogs(podName) if err != nil { return shellapi.ErrorMsg(\"Logs\", err.Error()) } return shellapi.InfoMsg(app+\" Logs\", podLogs) } // Terraform workflows func tfInit() string { result, err := shellapi.RunShell(\"terraform\", \"init\") if err != nil { return shellapi.ErrorMsg(\"Terraform\", err.Error()) } return shellapi.SuccessMsg(\"Terraform\", \"Initialized\") } func tfPlan() string { result, err := shellapi.RunShell(\"terraform\", \"plan\") if err != nil { return shellapi.ErrorMsg(\"Terraform\", err.Error()) } return shellapi.InfoMsg(\"Terraform Plan\", result) } func tfApply() string { fmt.Println(shellapi.Warning(\"\u26a0\ufe0f This will apply changes to infrastructure\")) // In real implementation, add confirmation prompt result, err := shellapi.RunShell(\"terraform\", \"apply\", \"-auto-approve\") if err != nil { return shellapi.ErrorMsg(\"Terraform\", err.Error()) } return shellapi.SuccessMsg(\"Terraform\", \"Applied changes\") } // AWS CLI helpers func awsRegions() string { regions, err := shellapi.RunShell(\"aws\", \"ec2\", \"describe-regions\", \"--output\", \"table\") if err != nil { return shellapi.ErrorMsg(\"AWS\", err.Error()) } return shellapi.InfoMsg(\"AWS Regions\", regions) } func awsS3List() string { buckets, err := shellapi.RunShell(\"aws\", \"s3\", \"ls\") if err != nil { return shellapi.ErrorMsg(\"AWS S3\", err.Error()) } return shellapi.InfoMsg(\"S3 Buckets\", buckets) } // Helper functions func firstPod(app string) string { pods, err := shellapi.RunShell(\"kubectl\", \"get\", \"pods\", \"-l\", \"app=\"+app, \"-o\", \"jsonpath='{.items[0].metadata.name}'\") if err != nil { return \"\" } // Remove quotes and return return strings.ReplaceAll(pods, \"'\", \"\") }","title":"DevOps/Cloud Engineer Configuration"},{"location":"config/#project-management","text":"","title":"Project Management"},{"location":"config/#multi-project-workspace","text":"package main import ( \"fmt\" \"github.com/rsarv3006/gosh_lib/shellapi\" ) func init() { fmt.Println(\"\ud83d\udcc1 Multi-project workspace loaded!\") } // Project categories func goClient() string { return cdPath(\"~/projects/client-portal\") } func goApi() string { return cdPath(\"~/projects/api-server\") } func goAdmin() string { return cdPath(\"~/projects/admin-dashboard\") } // Environment switching func envDev() string { os.Setenv(\"NODE_ENV\", \"development\") os.Setenv(\"API_URL\", \"http://localhost:3000\") return shellapi.SuccessMsg(\"Environment\", \"Switched to development\") } func envStaging() string { os.Setenv(\"NODE_ENV\", \"staging\") os.Setenv(\"API_URL\", \"https://staging-api.example.com\") return shellapi.SuccessMsg(\"Environment\", \"Switched to staging\") } func envProd() string { os.Setenv(\"NODE_ENV\", \"production\") os.Setenv(\"API_URL\", \"https://api.example.com\") return shellapi.SuccessMsg(\"Environment\", \"Switched to production\") } // Project health check func projectHealth() string { msg := \"Project Health Report:\\n\" // Git status if gitStatus, err := shellapi.GitStatus(); err == nil { if gitStatus == \"\" { msg += shellapi.Success(\"\u2713 Git: Working tree clean\\n\") } else { msg += shellapi.Warning(\"\u26a0 Git: Uncommitted changes\\n\") } } // Dependencies if _, err := shellapi.NpmRun(\"test:dependencies\"); err != nil { msg += shellapi.Error(\"\u2717 Dependencies: Issues detected\\n\") } else { msg += shellapi.Success(\"\u2713 Dependencies: OK\\n\") } // Build status if _, err := shellapi.NpmRun(\"build:test\"); err != nil { msg += shellapi.Error(\"\u2717 Build: Failed\\n\") } else { msg += shellapi.Success(\"\u2713 Build: OK\\n\") } return msg } // Database operations func dbConnect() string { // Load environment dbUrl := os.Getenv(\"DATABASE_URL\") if dbUrl == \"\" { return shellapi.ErrorMsg(\"Database\", \"DATABASE_URL not set\") } // Test connection if _, err := shellapi.RunShell(\"pg_isready\", \"-d\", dbUrl); err != nil { return shellapi.ErrorMsg(\"Database\", \"Connection failed\") } return shellapi.SuccessMsg(\"Database\", \"Connected\") } func dbMigrate() string { msg := \"Running database migrations...\\n\" if migrate, err := shellapi.RunShell(\"npm\", \"run\", \"db:migrate\"); err != nil { return shellapi.ErrorMsg(\"Migration\", err.Error()) } return shellapi.SuccessMsg(\"Migration\", \"Completed\") + \"\\n\" + migrate } func dbSeed() string { msg := \"Seeding database...\\n\" if seed, err := shellapi.RunShell(\"npm\", \"run\", \"db:seed\"); err != nil { return shellapi.ErrorMsg(\"Seeding\", err.Error()) } return shellapi.SuccessMsg(\"Seeding\", \"Completed\") + \"\\n\" + seed }","title":"Multi-Project Workspace"},{"location":"config/#productivity-enhancers","text":"","title":"Productivity Enhancers"},{"location":"config/#system-information-and-monitoring","text":"package main import ( \"fmt\" \"github.com/rsarv3006/gosh_lib/shellapi\" ) func init() { fmt.Println(\"\ud83d\udcca System monitoring loaded!\") } // System info func sysInfo() string { info := shellapi.Bold(\"System Information:\\n\") if uptime, err := shellapi.Uptime(); err == nil { info += shellapi.Bold(\"Uptime: \") + uptime + \"\\n\" } if user, err := shellapi.Whoami(); err == nil { info += shellapi.Bold(\"User: \") + user + \"\\n\" } if hostname, err := shellapi.Hostname(); err == nil { info += shellapi.Bold(\"Host: \") + hostname + \"\\n\" } if arch, err := shellapi.Arch(); err == nil { info += shellapi.Bold(\"Arch: \") + arch + \"\\n\" } return info } // Memory and disk usage func sysUsage() string { msg := shellapi.Bold(\"System Usage:\\n\") if mem, err := shellapi.Free(); err == nil { msg += shellapi.Bold(\"Memory:\\n\") + mem + \"\\n\" } if disk, err := shellapi.Df(); err == nil { msg += shellapi.Bold(\"Disk:\\n\") + disk + \"\\n\" } return msg } // Process monitoring func psGrep(pattern string) string { if pattern == \"\" { return \"Usage: psGrep <pattern>\" } result, err := shellapi.RunShell(\"ps\", \"aux\", \"|\", \"grep\", pattern) if err != nil { return shellapi.ErrorMsg(\"Process search\", err.Error()) } return shellapi.InfoMsg(\"Processes matching \"+pattern, result) } func portsUsed() string { result, err := shellapi.RunShell(\"lsof\", \"-i\", \"-n\", \"-P\") if err != nil { return shellapi.ErrorMsg(\"Ports\", err.Error()) } return shellapi.InfoMsg(\"Used Ports\", result) }","title":"System Information and Monitoring"},{"location":"config/#file-management-tools","text":"package main import ( \"fmt\" \"github.com/rsarv3006/gosh_lib/shellapi\" ) func init() { fmt.Println(\"\ud83d\udcc2 File management tools loaded!\") } // Quick file operations func findLarge() string { result, err := shellapi.RunShell(\"find\", \".\", \"-type\", \"f\", \"-size\", \"+10M\", \"-exec\", \"ls\", \"-lh\", \"{}\", \";\") if err != nil { return shellapi.ErrorMsg(\"Find\", err.Error()) } return shellapi.InfoMsg(\"Large files (>10MB)\", result) } func findRecent(days int) string { if days <= 0 { days = 7 // default to 7 days } result, err := shellapi.RunShell(\"find\", \".\", \"-type\", \"f\", \"-mtime\", fmt.Sprintf(\"-%d\", days), \"-exec\", \"ls\", \"-lt\", \"{}\", \";\") if err != nil { return shellapi.ErrorMsg(\"Find\", err.Error()) } return shellapi.InfoMsg(fmt.Sprintf(\"Recent files (%d days)\", days), result) } func cleanTemp() string { msg := \"Cleaning temporary files...\\n\" // Remove common temp patterns patterns := []string{\"*~\", \"*.tmp\", \"*.swp\", \"*.bak\"} for _, pattern := range patterns { if result, err := shellapi.RunShell(\"find\", \".\", \"-name\", pattern, \"-delete\"); err == nil { if result == \"\" { msg += shellapi.Success(\"\u2713 Cleaned \" + pattern + \" files\\n\") } } } return shellapi.SuccessMsg(\"Cleanup\", \"Completed\") } // Project structure tools func treeFiles() string { result, err := shellapi.Tree() if err != nil { return shellapi.ErrorMsg(\"Tree\", err.Error()) } return result } func countByType(fileType string) string { if fileType == \"\" { return \"Usage: countByType <extension>\" } if !strings.HasPrefix(fileType, \".\") { fileType = \".\" + fileType } result, err := shellapi.RunShell(\"find\", \".\", \"-name\", \"*\"+fileType, \"|\", \"wc\", \"-l\") if err != nil { return shellapi.ErrorMsg(\"Count\", err.Error()) } count := strings.TrimSpace(result) return shellapi.InfoMsg(fileType+\" files\", count) }","title":"File Management Tools"},{"location":"config/#environment-specific-configs","text":"","title":"Environment-Specific Configs"},{"location":"config/#container-development","text":"package main import ( \"github.com/rsarv3006/gosh_lib/shellapi\" ) func init() { fmt.Println(\"\ud83d\udc33 Container development loaded!\") } // Docker utilities func dockerClean() string { msg := \"Cleaning Docker resources...\\n\" // Remove stopped containers if _, err := shellapi.RunShell(\"docker\", \"container\", \"prune\", \"-f\"); err == nil { msg += shellapi.Success(\"\u2713 Removed stopped containers\\n\") } // Remove unused images if _, err := shellapi.RunShell(\"docker\", \"image\", \"prune\", \"-f\"); err == nil { msg += shellapi.Success(\"\u2713 Removed unused images\\n\") } // Remove unused volumes if _, err := shellapi.RunShell(\"docker\", \"volume\", \"prune\", \"-f\"); err == nil { msg += shellapi.Success(\"\u2713 Removed unused volumes\\n\") } return shellapi.SuccessMsg(\"Docker\", \"Cleanup completed\") } func dockerLogs(container string) string { if logs, err := shellapi.DockerLogs(container); err == nil { return shellapi.InfoMsg(container+\" logs\", logs) } else { return shellapi.ErrorMsg(\"Docker\", err.Error()) } } func dockerStats() string { result, err := shellapi.RunShell(\"docker\", \"stats\", \"--no-stream\") if err != nil { return shellapi.ErrorMsg(\"Docker\", err.Error()) } return shellapi.InfoMsg(\"Container Stats\", result) }","title":"Container Development"},{"location":"config/#usage-examples","text":"After creating your config.go , access functions like this: # Development workflow gosh> buildAndTest() # Execute Go build and test gosh> quickCommit(\"fix bug\") # Quick commit with message gosh> projectHealth() # Check overall project status # Environment switching gosh> envStaging() # Switch to staging environment gosh> goApi() # Navigate to API project gosh> dbMigrate() # Run database migrations # System utilities gosh> sysInfo() # Show system information gosh> cleanTemp() # Clean temporary files gosh> findRecent(7) # Find files changed in last 7 days # Docker operations gosh> dockerClean() # Clean Docker resources gosh> dockerLogs(\"web\") # Show logs for web container","title":"Usage Examples"},{"location":"config/#best-practices","text":"Start simple : Begin with basic functions and expand as needed Group related functions : Use prefixes like go* , db* , docker* Add error handling : Always check for errors and provide feedback Use color functions : Make output more readable with Success() , Error() , etc. Document your functions : Add comments explaining what each function does Test your configs : Reload gosh and test functions before relying on them Ready for the complete reference? Check out our CLI Reference for all available commands and shellapi functions!","title":"Best Practices"},{"location":"getting-started/","text":"Getting Started Welcome to gosh! This guide will help you get comfortable with the hybrid shell experience that combines Go programming with traditional shell commands. Your First Session Start gosh by simply running: gosh You'll see a welcome message and the gosh prompt: gosh 0.2.3 - Go shell with yaegi (BUILT: 2023-10-17 15:30:45) Type 'exit' to quit, try some Go code or shell commands! gosh> Basic Usage Traditional Shell Commands All your favorite shell commands work exactly as you'd expect: gosh> ls README.md main.go go.mod go.sum gosh> pwd /Users/username/projects/gosh gosh> git status On branch main nothing to commit, working tree clean Go Code in the Shell Now try writing some Go code: gosh> name := \"gosh\" gosh> fmt.Printf(\"Hello %s!\\n\", name) Hello gosh! gosh> x := 42 gosh> y := x * 2 gosh> fmt.Printf(\"x=%d, y=%d\\n\", x, y) x=42, y=84 Functions and Control Flow Write functions and use control structures with proper multiline support: gosh> func greet(name string) { ... fmt.Printf(\"Hello, %s! Welcome to gosh!\\n\", name) ... } gosh> greet(\"developer\") Hello, developer! Welcome to gosh! gosh> for i := 0; i < 3; i++ { ... fmt.Printf(\"Count: %d\\n\", i) ... } Count: 0 Count: 1 Count: 2 Command Substitution The game-changing feature: capture command output into Go variables: gosh> files := $(ls) gosh> fmt.Printf(\"Found %d files\\n\", len(strings.Split(files, \"\\n\"))) Found 6 files gosh> currentDir := $(pwd) gosh> fmt.Printf(\"Current directory: %s\", currentDir) Current directory: /Users/username/projects/gosh Pre-imported Packages gosh automatically imports common packages, so you can use them without explicit imports: gosh> files, _ := filepath.Glob(\"*.go\") gosh> fmt.Println(files) [main.go repl.go router.go ...] gosh> currentDir, _ := os.Getwd() gosh> fmt.Println(currentDir) /Users/username/projects/gosh gosh> timestamp := time.Now().Format(\"2006-01-02\") gosh> fmt.Println(timestamp) 2023-10-17 Built-in Commands gosh provides essential built-in commands: gosh> help Available built-ins: - cd <path> Change directory - pwd Print working directory - exit Exit gosh - init Create example config - help Show this help gosh> cd /tmp gosh> pwd /tmp gosh> exit Navigation and History Use arrow keys for history navigation: gosh> # Press up arrow to see previous commands gosh> ls -la # Previously typed gosh> name := \"test\" # Previously typed Error Handling Errors show line numbers and helpful messages: gosh> fmt.Println(undefined_var) Error: undefined: undefined_var on line 1 Combining Go and Shell The real power comes from mixing both approaches: # Get git status and process it in Go gosh> gitStatus := $(git status --porcelain) gosh> if gitStatus == \"\" { ... fmt.Println(\"\u2705 Working directory is clean\") ... } else { ... fmt.Println(\"\u26a0\ufe0f Working directory has changes\") ... } gosh> lines := strings.Split(gitStatus, \"\\n\") gosh> fmt.Printf(\"Found %d changed files\\n\", len(lines)-1) Next Steps Now that you understand the basics: Installation Guide - Install gosh on your system Configuration - Set up custom functions and shortcuts User Guide - Advanced features and workflows CLI Reference - Complete command and API reference Pro Tips 1. Use Variables for Common Commands gosh> lsCmd := \"ls --color=auto\" gosh> result := $(lsCmd) gosh> fmt.Println(result) 2. Create Quick Helpers gosh> func quickGit() { ... status, _ := shellapi.GitStatus() ... fmt.Println(status) ... } gosh> quickGit() 3. Chain Operations gosh> files := $(ls *.go) gosh> for _, file := range strings.Split(files, \"\\n\") { ... if file != \"\" { ... fmt.Printf(\"Processing: %s\\n\", file) ... } ... } Ready to dive deeper? Check out our comprehensive User Guide for advanced workflows and customization options!","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"Welcome to gosh! This guide will help you get comfortable with the hybrid shell experience that combines Go programming with traditional shell commands.","title":"Getting Started"},{"location":"getting-started/#your-first-session","text":"Start gosh by simply running: gosh You'll see a welcome message and the gosh prompt: gosh 0.2.3 - Go shell with yaegi (BUILT: 2023-10-17 15:30:45) Type 'exit' to quit, try some Go code or shell commands! gosh>","title":"Your First Session"},{"location":"getting-started/#basic-usage","text":"","title":"Basic Usage"},{"location":"getting-started/#traditional-shell-commands","text":"All your favorite shell commands work exactly as you'd expect: gosh> ls README.md main.go go.mod go.sum gosh> pwd /Users/username/projects/gosh gosh> git status On branch main nothing to commit, working tree clean","title":"Traditional Shell Commands"},{"location":"getting-started/#go-code-in-the-shell","text":"Now try writing some Go code: gosh> name := \"gosh\" gosh> fmt.Printf(\"Hello %s!\\n\", name) Hello gosh! gosh> x := 42 gosh> y := x * 2 gosh> fmt.Printf(\"x=%d, y=%d\\n\", x, y) x=42, y=84","title":"Go Code in the Shell"},{"location":"getting-started/#functions-and-control-flow","text":"Write functions and use control structures with proper multiline support: gosh> func greet(name string) { ... fmt.Printf(\"Hello, %s! Welcome to gosh!\\n\", name) ... } gosh> greet(\"developer\") Hello, developer! Welcome to gosh! gosh> for i := 0; i < 3; i++ { ... fmt.Printf(\"Count: %d\\n\", i) ... } Count: 0 Count: 1 Count: 2","title":"Functions and Control Flow"},{"location":"getting-started/#command-substitution","text":"The game-changing feature: capture command output into Go variables: gosh> files := $(ls) gosh> fmt.Printf(\"Found %d files\\n\", len(strings.Split(files, \"\\n\"))) Found 6 files gosh> currentDir := $(pwd) gosh> fmt.Printf(\"Current directory: %s\", currentDir) Current directory: /Users/username/projects/gosh","title":"Command Substitution"},{"location":"getting-started/#pre-imported-packages","text":"gosh automatically imports common packages, so you can use them without explicit imports: gosh> files, _ := filepath.Glob(\"*.go\") gosh> fmt.Println(files) [main.go repl.go router.go ...] gosh> currentDir, _ := os.Getwd() gosh> fmt.Println(currentDir) /Users/username/projects/gosh gosh> timestamp := time.Now().Format(\"2006-01-02\") gosh> fmt.Println(timestamp) 2023-10-17","title":"Pre-imported Packages"},{"location":"getting-started/#built-in-commands","text":"gosh provides essential built-in commands: gosh> help Available built-ins: - cd <path> Change directory - pwd Print working directory - exit Exit gosh - init Create example config - help Show this help gosh> cd /tmp gosh> pwd /tmp gosh> exit","title":"Built-in Commands"},{"location":"getting-started/#navigation-and-history","text":"Use arrow keys for history navigation: gosh> # Press up arrow to see previous commands gosh> ls -la # Previously typed gosh> name := \"test\" # Previously typed","title":"Navigation and History"},{"location":"getting-started/#error-handling","text":"Errors show line numbers and helpful messages: gosh> fmt.Println(undefined_var) Error: undefined: undefined_var on line 1","title":"Error Handling"},{"location":"getting-started/#combining-go-and-shell","text":"The real power comes from mixing both approaches: # Get git status and process it in Go gosh> gitStatus := $(git status --porcelain) gosh> if gitStatus == \"\" { ... fmt.Println(\"\u2705 Working directory is clean\") ... } else { ... fmt.Println(\"\u26a0\ufe0f Working directory has changes\") ... } gosh> lines := strings.Split(gitStatus, \"\\n\") gosh> fmt.Printf(\"Found %d changed files\\n\", len(lines)-1)","title":"Combining Go and Shell"},{"location":"getting-started/#next-steps","text":"Now that you understand the basics: Installation Guide - Install gosh on your system Configuration - Set up custom functions and shortcuts User Guide - Advanced features and workflows CLI Reference - Complete command and API reference","title":"Next Steps"},{"location":"getting-started/#pro-tips","text":"","title":"Pro Tips"},{"location":"getting-started/#1-use-variables-for-common-commands","text":"gosh> lsCmd := \"ls --color=auto\" gosh> result := $(lsCmd) gosh> fmt.Println(result)","title":"1. Use Variables for Common Commands"},{"location":"getting-started/#2-create-quick-helpers","text":"gosh> func quickGit() { ... status, _ := shellapi.GitStatus() ... fmt.Println(status) ... } gosh> quickGit()","title":"2. Create Quick Helpers"},{"location":"getting-started/#3-chain-operations","text":"gosh> files := $(ls *.go) gosh> for _, file := range strings.Split(files, \"\\n\") { ... if file != \"\" { ... fmt.Printf(\"Processing: %s\\n\", file) ... } ... } Ready to dive deeper? Check out our comprehensive User Guide for advanced workflows and customization options!","title":"3. Chain Operations"},{"location":"guide/","text":"User Guide Master the advanced features of gosh with this comprehensive user guide covering configuration, shellapi functions, and productivity workflows. Configuration Strategy gosh uses a dual-layer configuration approach that gives you the best of both worlds: standard shell compatibility plus Go-powered extensions. Layer 1: Standard Shell Environment ( env.go ) Automatic Standard Config Loading: gosh loads regular shell configs when run as login shell, supporting: - .bash_profile , .zprofile , .profile , .bash_login , .login - Full POSIX environment inheritance - Shell variable expansion $HOME , $PATH , $GOPATH Example .bash_profile # Your existing shell configs just work! export PATH=\"/opt/homebrew/bin:$PATH\" export GOPATH=\"$HOME/go\" export EDITOR=\"vim\" export JAVA_HOME=\"/usr/local/opt/openjdk\" Layer 2: Go-Powered Extensions ( config.go ) Create a Go file for your global shell customization at: ~/.config/gosh/config.go This single global config loads every time gosh starts, providing consistent shell behavior across all projects. // ~/.config/gosh/config.go package main import ( \"fmt\" \"os\" ) func init() { // Global environment setup os.Setenv(\"GOPATH\", os.Getenv(\"HOME\") + \"/go\") os.Setenv(\"EDITOR\", \"vim\") fmt.Println(\"gosh global config loaded!\") } // Global functions available in any gosh session func info() { fmt.Printf(\"gosh %s - GOPATH: %s, EDITOR: %s\\n\", \"main\".GetVersion(), os.Getenv(\"GOPATH\"), os.Getenv(\"EDITOR\")) } func clean(a string) string { return strings.TrimSpace(a) } Working with Shellapi Functions gosh v0.2.2 features working shellapi functions that execute real commands via Go's os/exec , providing actual command output and persistent directory changes. Development Workflow Functions // ~/.config/gosh/config.go package main import ( \"fmt\" \"github.com/rsarv3006/gosh_lib/shellapi\" ) func init() { fmt.Println(\"\ud83d\ude80 gosh config loaded! Command execution system enabled!\") } // Functions that actually execute real commands func build() string { result, err := shellapi.GoBuild() if err != nil { return \"BUILD ERROR: \" + err.Error() } return \"BUILD SUCCESS: \" + result } func test() string { result, _ := shellapi.GoTest() return result } func run() string { result, _ := shellapi.GoRun() return result } func gs() string { result, err := shellapi.GitStatus() if err != nil { return \"GIT ERROR: \" + err.Error() } return \"GIT STATUS:\\n\" + result } Directory Navigation Functions Directory changes actually persist in the shell session: // Directory changing functions that actually change directories! func goGosh() string { result, err := shellapi.RunShell(\"cd\", \"/Users/rjs/dev/gosh\") if err != nil { return \"CD ERROR: \" + err.Error() } return result // Returns CD marker for processing } func goConfig() string { result, err := shellapi.RunShell(\"cd\", \"/Users/rjs/.config/gosh/\") if err != nil { return \"CD ERROR: \" + err.Error() } return result } func goProjects() string { result, err := shellapi.RunShell(\"cd\", \"~/projects\") if err != nil { return \"ERROR: \" + err.Error() } return result } Usage Examples # These actually execute real commands! gosh> build() # Executes real go build command gosh> test() # Executes real go test command gosh> run() # Executes real go run . command gosh> gs() # Executes real git status with full output # These actually change directories! gosh> goGosh() # Changes to ~/dev/gosh - directory persists! gosh> goConfig() # Changes to ~/.config/gosh/ - directory persists! gosh> pwd /Users/rjs/dev/gosh # Directory actually changed Advanced Command Usage RunShell Command Engine The shellapi.RunShell function is the core command execution engine: // Basic command execution result, err := shellapi.RunShell(\"command\", \"arg1\", \"arg2\") // Development tools build := shellapi.RunShell(\"go\", \"build\") tests := shellapi.RunShell(\"go\", \"test\", \"./...\") // System commands uptime := shellapi.RunShell(\"uptime\") ps := shellapi.RunShell(\"ps\", \"aux\") // Directory changes with persistence result, err := shellapi.RunShell(\"cd\", \"/path/to/project\") if err != nil { return \"CD ERROR: \" + err.Error() } return result // Directory actually changes Error Handling Patterns func buildAndTest() string { // Build first build, buildErr := shellapi.GoBuild() if buildErr != nil { return \"BUILD FAILED: \" + buildErr.Error() } // Then test test, testErr := shellapi.GoTest() if testErr != nil { return \"TESTS FAILED: \" + testErr.Error() } return \"\u2705 Build successful\\n\" + test } func deployTo(prodEnv string) string { msg := \"Deploying to \" + prodEnv + \"...\\n\" // Check git status status, _ := shellapi.GitStatus() if status != \"\" { msg += \"\u26a0\ufe0f Working tree not clean:\\n\" + status return msg } // Deploy result, err := shellapi.RunShell(\"ansible-playbook\", \"deploy.yml\", \"-e\", \"env=\"+prodEnv) if err != nil { return \"DEPLOY ERROR: \" + err.Error() } return msg + \"\u2705 Deployment complete\" } Project-Specific Workflow Multi-Environment Development // Environment-based project management func goEnv(env string) string { var path string switch env { case \"dev\": path = \"~/projects/myapp-dev\" case \"staging\": path = \"~/projects/myapp-staging\" case \"prod\": path = \"~/projects/myapp-prod\" default: return \"Unknown environment: \" + env } result, err := shellapi.RunShell(\"cd\", path) if err != nil { return \"ERROR: \" + err.Error() } return result } // Usage: // gosh> goEnv(\"dev\") # Goes to dev environment // gosh> goEnv(\"prod\") # Goes to prod environment Database Operations func dbConnect(env string) string { var dbUrl string switch env { case \"dev\": dbUrl = \"postgresql://user:pass@localhost/devdb\" case \"prod\": dbUrl = \"postgresql://user:pass@prod-server/proddb\" } result, err := shellapi.RunShell(\"psql\", dbUrl) return \"Connected to \" + env + \" database\\n\" + result } func dbMigrate(env string) string { msg := \"Migrating \" + env + \" database...\\n\" // Run migrations migrate, err := shellapi.RunShell(\"npm\", \"run\", \"db:migrate\") if err != nil { return \"MIGRATION ERROR: \" + err.Error() } return msg + migrate } Productivity Tips Git Workflow Automation func quickCommit(msg string) string { status, _ := shellapi.GitStatus() if status == \"\" { return \"Nothing to commit\" } // Add all changes shellapi.GitAdd(\".\") // Create commit commit, err := shellapi.GitCommit(msg) if err != nil { return \"COMMIT ERROR: \" + err.Error() } return \"\u2705 Committed: \" + msg } func syncBranch() string { msg := \"Syncing branch with remote...\\n\" // Pull latest pull, err := shellapi.GitPull() if err != nil { return \"PULL ERROR: \" + err.Error() } // Push local changes push, err := shellapi.GitPush() if err != nil { return \"PUSH ERROR: \" + err.Error() } return msg + \"\u2705 Branch synced\" } File Management func projectInfo() string { info := shellapi.Bold(\"Project Information:\\n\") // Git status if gitStatus, err := shellapi.GitStatus(); err == nil { info += shellapi.Bold(\"Git: \") + gitStatus + \"\\n\" } # File count if files, _ := shellapi.Ls(); files != \"\" { fileCount := len(strings.Split(strings.TrimSpace(files), \"\\n\")) info += shellapi.Bold(\"Files: \") + fmt.Sprintf(\"%d files\\n\", fileCount) } # Directory size if du, _ := shellapi.RunShell(\"du\", \"-sh\", \".\"); du != \"\" { parts := strings.Split(strings.TrimSpace(du), \"\\t\") if len(parts) > 0 { info += shellapi.Bold(\"Size: \") + parts[0] + \"\\n\" } } return info } func cleanProject() string { msg := \"Cleaning project...\\n\" # Remove temporary files if _, err := shellapi.RunShell(\"find\", \".\", \"-name\", \"*.tmp\", \"-delete\"); err == nil { msg += shellapi.Success(\"\u2713 Removed temporary files\\n\") } # Remove build artifacts if _, err := shellapi.RunShell(\"rm\", \"-rf\", \"dist/\", \"build/\"); err == nil { msg += shellapi.Success(\"\u2713 Removed build artifacts\\n\") } return msg } Color and Formatting Functions Use the color functions to make your output more readable: func projectStatus() string { status, _ := shellapi.GitStatus() if status == \"\" { return shellapi.Success(\"\u2713 Working tree is clean\") } return shellapi.Warning(\"\u26a0 Working tree has changes:\\n\") + shellapi.Highlight(strings.TrimSpace(status)) } func buildReport() string { result, err := shellapi.GoBuild() if err != nil { return shellapi.Error(\"\u2717 Build failed:\") + \"\\n\" + err.Error() } return shellapi.Success(\"\u2713 Build successful\") + \"\\n\" + result } func infoMessage() string { return shellapi.InfoMsg(\"Info\", \"This is an informational message\") } func debugMessage() string { return shellapi.DebugMsg(\"Debug\", \"Detailed diagnostics information\") } Advanced Patterns Lazy Loading Commands var ( projectCache map[string]string cacheLoaded bool ) func getProjectInfo(project string) string { if !cacheLoaded { loadProjectCache() cacheLoaded = true } if info, exists := projectCache[project]; exists { return info } return \"Project not found: \" + project } func loadProjectCache() { projectCache = make(map[string]string) // Load project information lazily // ... implementation } Interactive Workflows func interactiveDeploy() string { // Check if we're in a git repo if _, err := shellapi.GitStatus(); err != nil { return \"Not in a git repository\" } fmt.Println(shellapi.Question(\"Deploy to which environment? (dev/staging/prod)\")) // In real implementation, you'd read user input here // Example: deploy to staging return deployTo(\"staging\") } Best Practices Performance Tips Cache expensive operations : Store results of expensive commands Use shellapi functions : Pre-built functions are optimized Validate inputs : Check parameters before executing commands Handle errors : Always check for errors and provide feedback Error Handling Always check err != nil before using results Return meaningful error messages Provide context about what went wrong Use color functions to highlight errors Function Naming Use descriptive names: goGosh() , buildAndTest() , projectInfo() Follow Go naming conventions Group related functions with prefixes: go* for navigation, db* for database Ready to explore specific configurations? Check out our Configuration Examples or the complete CLI Reference !","title":"User Guide"},{"location":"guide/#user-guide","text":"Master the advanced features of gosh with this comprehensive user guide covering configuration, shellapi functions, and productivity workflows.","title":"User Guide"},{"location":"guide/#configuration-strategy","text":"gosh uses a dual-layer configuration approach that gives you the best of both worlds: standard shell compatibility plus Go-powered extensions.","title":"Configuration Strategy"},{"location":"guide/#layer-1-standard-shell-environment-envgo","text":"Automatic Standard Config Loading: gosh loads regular shell configs when run as login shell, supporting: - .bash_profile , .zprofile , .profile , .bash_login , .login - Full POSIX environment inheritance - Shell variable expansion $HOME , $PATH , $GOPATH Example .bash_profile # Your existing shell configs just work! export PATH=\"/opt/homebrew/bin:$PATH\" export GOPATH=\"$HOME/go\" export EDITOR=\"vim\" export JAVA_HOME=\"/usr/local/opt/openjdk\"","title":"Layer 1: Standard Shell Environment (env.go)"},{"location":"guide/#layer-2-go-powered-extensions-configgo","text":"Create a Go file for your global shell customization at: ~/.config/gosh/config.go This single global config loads every time gosh starts, providing consistent shell behavior across all projects. // ~/.config/gosh/config.go package main import ( \"fmt\" \"os\" ) func init() { // Global environment setup os.Setenv(\"GOPATH\", os.Getenv(\"HOME\") + \"/go\") os.Setenv(\"EDITOR\", \"vim\") fmt.Println(\"gosh global config loaded!\") } // Global functions available in any gosh session func info() { fmt.Printf(\"gosh %s - GOPATH: %s, EDITOR: %s\\n\", \"main\".GetVersion(), os.Getenv(\"GOPATH\"), os.Getenv(\"EDITOR\")) } func clean(a string) string { return strings.TrimSpace(a) }","title":"Layer 2: Go-Powered Extensions (config.go)"},{"location":"guide/#working-with-shellapi-functions","text":"gosh v0.2.2 features working shellapi functions that execute real commands via Go's os/exec , providing actual command output and persistent directory changes.","title":"Working with Shellapi Functions"},{"location":"guide/#development-workflow-functions","text":"// ~/.config/gosh/config.go package main import ( \"fmt\" \"github.com/rsarv3006/gosh_lib/shellapi\" ) func init() { fmt.Println(\"\ud83d\ude80 gosh config loaded! Command execution system enabled!\") } // Functions that actually execute real commands func build() string { result, err := shellapi.GoBuild() if err != nil { return \"BUILD ERROR: \" + err.Error() } return \"BUILD SUCCESS: \" + result } func test() string { result, _ := shellapi.GoTest() return result } func run() string { result, _ := shellapi.GoRun() return result } func gs() string { result, err := shellapi.GitStatus() if err != nil { return \"GIT ERROR: \" + err.Error() } return \"GIT STATUS:\\n\" + result }","title":"Development Workflow Functions"},{"location":"guide/#directory-navigation-functions","text":"Directory changes actually persist in the shell session: // Directory changing functions that actually change directories! func goGosh() string { result, err := shellapi.RunShell(\"cd\", \"/Users/rjs/dev/gosh\") if err != nil { return \"CD ERROR: \" + err.Error() } return result // Returns CD marker for processing } func goConfig() string { result, err := shellapi.RunShell(\"cd\", \"/Users/rjs/.config/gosh/\") if err != nil { return \"CD ERROR: \" + err.Error() } return result } func goProjects() string { result, err := shellapi.RunShell(\"cd\", \"~/projects\") if err != nil { return \"ERROR: \" + err.Error() } return result }","title":"Directory Navigation Functions"},{"location":"guide/#usage-examples","text":"# These actually execute real commands! gosh> build() # Executes real go build command gosh> test() # Executes real go test command gosh> run() # Executes real go run . command gosh> gs() # Executes real git status with full output # These actually change directories! gosh> goGosh() # Changes to ~/dev/gosh - directory persists! gosh> goConfig() # Changes to ~/.config/gosh/ - directory persists! gosh> pwd /Users/rjs/dev/gosh # Directory actually changed","title":"Usage Examples"},{"location":"guide/#advanced-command-usage","text":"","title":"Advanced Command Usage"},{"location":"guide/#runshell-command-engine","text":"The shellapi.RunShell function is the core command execution engine: // Basic command execution result, err := shellapi.RunShell(\"command\", \"arg1\", \"arg2\") // Development tools build := shellapi.RunShell(\"go\", \"build\") tests := shellapi.RunShell(\"go\", \"test\", \"./...\") // System commands uptime := shellapi.RunShell(\"uptime\") ps := shellapi.RunShell(\"ps\", \"aux\") // Directory changes with persistence result, err := shellapi.RunShell(\"cd\", \"/path/to/project\") if err != nil { return \"CD ERROR: \" + err.Error() } return result // Directory actually changes","title":"RunShell Command Engine"},{"location":"guide/#error-handling-patterns","text":"func buildAndTest() string { // Build first build, buildErr := shellapi.GoBuild() if buildErr != nil { return \"BUILD FAILED: \" + buildErr.Error() } // Then test test, testErr := shellapi.GoTest() if testErr != nil { return \"TESTS FAILED: \" + testErr.Error() } return \"\u2705 Build successful\\n\" + test } func deployTo(prodEnv string) string { msg := \"Deploying to \" + prodEnv + \"...\\n\" // Check git status status, _ := shellapi.GitStatus() if status != \"\" { msg += \"\u26a0\ufe0f Working tree not clean:\\n\" + status return msg } // Deploy result, err := shellapi.RunShell(\"ansible-playbook\", \"deploy.yml\", \"-e\", \"env=\"+prodEnv) if err != nil { return \"DEPLOY ERROR: \" + err.Error() } return msg + \"\u2705 Deployment complete\" }","title":"Error Handling Patterns"},{"location":"guide/#project-specific-workflow","text":"","title":"Project-Specific Workflow"},{"location":"guide/#multi-environment-development","text":"// Environment-based project management func goEnv(env string) string { var path string switch env { case \"dev\": path = \"~/projects/myapp-dev\" case \"staging\": path = \"~/projects/myapp-staging\" case \"prod\": path = \"~/projects/myapp-prod\" default: return \"Unknown environment: \" + env } result, err := shellapi.RunShell(\"cd\", path) if err != nil { return \"ERROR: \" + err.Error() } return result } // Usage: // gosh> goEnv(\"dev\") # Goes to dev environment // gosh> goEnv(\"prod\") # Goes to prod environment","title":"Multi-Environment Development"},{"location":"guide/#database-operations","text":"func dbConnect(env string) string { var dbUrl string switch env { case \"dev\": dbUrl = \"postgresql://user:pass@localhost/devdb\" case \"prod\": dbUrl = \"postgresql://user:pass@prod-server/proddb\" } result, err := shellapi.RunShell(\"psql\", dbUrl) return \"Connected to \" + env + \" database\\n\" + result } func dbMigrate(env string) string { msg := \"Migrating \" + env + \" database...\\n\" // Run migrations migrate, err := shellapi.RunShell(\"npm\", \"run\", \"db:migrate\") if err != nil { return \"MIGRATION ERROR: \" + err.Error() } return msg + migrate }","title":"Database Operations"},{"location":"guide/#productivity-tips","text":"","title":"Productivity Tips"},{"location":"guide/#git-workflow-automation","text":"func quickCommit(msg string) string { status, _ := shellapi.GitStatus() if status == \"\" { return \"Nothing to commit\" } // Add all changes shellapi.GitAdd(\".\") // Create commit commit, err := shellapi.GitCommit(msg) if err != nil { return \"COMMIT ERROR: \" + err.Error() } return \"\u2705 Committed: \" + msg } func syncBranch() string { msg := \"Syncing branch with remote...\\n\" // Pull latest pull, err := shellapi.GitPull() if err != nil { return \"PULL ERROR: \" + err.Error() } // Push local changes push, err := shellapi.GitPush() if err != nil { return \"PUSH ERROR: \" + err.Error() } return msg + \"\u2705 Branch synced\" }","title":"Git Workflow Automation"},{"location":"guide/#file-management","text":"func projectInfo() string { info := shellapi.Bold(\"Project Information:\\n\") // Git status if gitStatus, err := shellapi.GitStatus(); err == nil { info += shellapi.Bold(\"Git: \") + gitStatus + \"\\n\" } # File count if files, _ := shellapi.Ls(); files != \"\" { fileCount := len(strings.Split(strings.TrimSpace(files), \"\\n\")) info += shellapi.Bold(\"Files: \") + fmt.Sprintf(\"%d files\\n\", fileCount) } # Directory size if du, _ := shellapi.RunShell(\"du\", \"-sh\", \".\"); du != \"\" { parts := strings.Split(strings.TrimSpace(du), \"\\t\") if len(parts) > 0 { info += shellapi.Bold(\"Size: \") + parts[0] + \"\\n\" } } return info } func cleanProject() string { msg := \"Cleaning project...\\n\" # Remove temporary files if _, err := shellapi.RunShell(\"find\", \".\", \"-name\", \"*.tmp\", \"-delete\"); err == nil { msg += shellapi.Success(\"\u2713 Removed temporary files\\n\") } # Remove build artifacts if _, err := shellapi.RunShell(\"rm\", \"-rf\", \"dist/\", \"build/\"); err == nil { msg += shellapi.Success(\"\u2713 Removed build artifacts\\n\") } return msg }","title":"File Management"},{"location":"guide/#color-and-formatting-functions","text":"Use the color functions to make your output more readable: func projectStatus() string { status, _ := shellapi.GitStatus() if status == \"\" { return shellapi.Success(\"\u2713 Working tree is clean\") } return shellapi.Warning(\"\u26a0 Working tree has changes:\\n\") + shellapi.Highlight(strings.TrimSpace(status)) } func buildReport() string { result, err := shellapi.GoBuild() if err != nil { return shellapi.Error(\"\u2717 Build failed:\") + \"\\n\" + err.Error() } return shellapi.Success(\"\u2713 Build successful\") + \"\\n\" + result } func infoMessage() string { return shellapi.InfoMsg(\"Info\", \"This is an informational message\") } func debugMessage() string { return shellapi.DebugMsg(\"Debug\", \"Detailed diagnostics information\") }","title":"Color and Formatting Functions"},{"location":"guide/#advanced-patterns","text":"","title":"Advanced Patterns"},{"location":"guide/#lazy-loading-commands","text":"var ( projectCache map[string]string cacheLoaded bool ) func getProjectInfo(project string) string { if !cacheLoaded { loadProjectCache() cacheLoaded = true } if info, exists := projectCache[project]; exists { return info } return \"Project not found: \" + project } func loadProjectCache() { projectCache = make(map[string]string) // Load project information lazily // ... implementation }","title":"Lazy Loading Commands"},{"location":"guide/#interactive-workflows","text":"func interactiveDeploy() string { // Check if we're in a git repo if _, err := shellapi.GitStatus(); err != nil { return \"Not in a git repository\" } fmt.Println(shellapi.Question(\"Deploy to which environment? (dev/staging/prod)\")) // In real implementation, you'd read user input here // Example: deploy to staging return deployTo(\"staging\") }","title":"Interactive Workflows"},{"location":"guide/#best-practices","text":"","title":"Best Practices"},{"location":"guide/#performance-tips","text":"Cache expensive operations : Store results of expensive commands Use shellapi functions : Pre-built functions are optimized Validate inputs : Check parameters before executing commands Handle errors : Always check for errors and provide feedback","title":"Performance Tips"},{"location":"guide/#error-handling","text":"Always check err != nil before using results Return meaningful error messages Provide context about what went wrong Use color functions to highlight errors","title":"Error Handling"},{"location":"guide/#function-naming","text":"Use descriptive names: goGosh() , buildAndTest() , projectInfo() Follow Go naming conventions Group related functions with prefixes: go* for navigation, db* for database Ready to explore specific configurations? Check out our Configuration Examples or the complete CLI Reference !","title":"Function Naming"},{"location":"install/","text":"Installation Get gosh running on your system with these simple installation methods. Homebrew (Recommended) The easiest way to install gosh is via Homebrew: # Install via homebrew tap brew install rsarv3006/gosh/gosh # Add to system shells (optional, to use as login shell) echo '/opt/homebrew/bin/gosh' | sudo tee -a /etc/shells # Set as default shell (optional) chsh -s /opt/homebrew/bin/gosh # Run gosh Go Install If you have Go installed, you can directly install the latest release: # Install the latest release go install github.com/rsarv3006/gosh@latest # Make sure your Go bin directory is in your PATH export PATH=$PATH:$(go env GOPATH)/bin # Run gosh Build from Source For developers or those who want the latest development version: # Clone the repository git clone https://github.com/rsarv3006/gosh cd gosh # Build go build # Run ./gosh # Or install for system-wide use go install . System Requirements Operating System : macOS, Linux (Windows users can use PowerShell as an alternative) Go : Version 1.21 or higher (for building from source) Architecture : amd64, arm64 Verify Installation Once installed, verify gosh is working: # Check version gosh --version # Or inside gosh gosh> fmt.Println(\"main\".GetVersion()) 0.2.3 # Help command gosh --help PATH Configuration Make sure gosh is in your PATH: For Go Install Users # Add this to your ~/.zshrc or ~/.bashrc export PATH=$PATH:$(go env GOPATH)/bin # Reload your shell source ~/.zshrc # or ~/.bashrc For Homebrew Users Homebrew automatically configures the PATH, but you may need to start a new terminal session. Usage Modes Interactive Shell The most common usage - start an interactive session: gosh Single Command Execution Execute a single command and exit: gosh -c 'fmt.Println(\"Hello from gosh\")' # Or with shell commands gosh -c 'ls -la' # With Go code gosh -c 'files := $(ls); fmt.Printf(\"Found %d files\\n\", len(strings.Split(files, \"\\n\")))' As Login Shell Make gosh your default shell: # Add to available shells echo $(which gosh) | sudo tee -a /etc/shells # Set as default shell chsh -s $(which gosh) Post-Installation Setup Create Configuration Directory Set up your gosh configuration: # Create config directory mkdir -p ~/.config/gosh # Initialize with example config gosh gosh> init This creates an example ~/.config/gosh/config.go file with useful functions. Verify Functions Test some built-in functions: gosh> gs # Git status helper gosh> build() # Build helper gosh> test() # Test helper Troubleshooting Common Issues Command not found: gosh # Check if gosh is in PATH which gosh # If not found, add Go bin directory to PATH export PATH=$PATH:$(go env GOPATH)/bin Permission denied # Make sure gosh is executable chmod +x $(which gosh) Config loading errors # Check config directory permissions ls -la ~/.config/gosh/ # If needed, fix permissions chmod 755 ~/.config/gosh Go not installed # Install Go on macOS brew install go # Or download from https://go.dev/ Getting Help If you encounter issues: Check this troubleshooting section Review the User Guide for configuration help Open an issue on GitHub Upgrade Instructions Homebrew Users brew upgrade rsarv3006/gosh/gosh Go Install Users go install github.com/rsarv3006/gosh@latest Source Users cd gosh git pull origin main go build What's Next? Once gosh is installed and working: Getting Started Guide - Learn basic usage Configuration Examples - Set up custom functions User Guide - Advanced features CLI Reference - Complete command documentation Enjoy your enhanced shell experience! \ud83d\ude80","title":"Installation"},{"location":"install/#installation","text":"Get gosh running on your system with these simple installation methods.","title":"Installation"},{"location":"install/#homebrew-recommended","text":"The easiest way to install gosh is via Homebrew: # Install via homebrew tap brew install rsarv3006/gosh/gosh # Add to system shells (optional, to use as login shell) echo '/opt/homebrew/bin/gosh' | sudo tee -a /etc/shells # Set as default shell (optional) chsh -s /opt/homebrew/bin/gosh # Run gosh","title":"Homebrew (Recommended)"},{"location":"install/#go-install","text":"If you have Go installed, you can directly install the latest release: # Install the latest release go install github.com/rsarv3006/gosh@latest # Make sure your Go bin directory is in your PATH export PATH=$PATH:$(go env GOPATH)/bin # Run gosh","title":"Go Install"},{"location":"install/#build-from-source","text":"For developers or those who want the latest development version: # Clone the repository git clone https://github.com/rsarv3006/gosh cd gosh # Build go build # Run ./gosh # Or install for system-wide use go install .","title":"Build from Source"},{"location":"install/#system-requirements","text":"Operating System : macOS, Linux (Windows users can use PowerShell as an alternative) Go : Version 1.21 or higher (for building from source) Architecture : amd64, arm64","title":"System Requirements"},{"location":"install/#verify-installation","text":"Once installed, verify gosh is working: # Check version gosh --version # Or inside gosh gosh> fmt.Println(\"main\".GetVersion()) 0.2.3 # Help command gosh --help","title":"Verify Installation"},{"location":"install/#path-configuration","text":"Make sure gosh is in your PATH:","title":"PATH Configuration"},{"location":"install/#for-go-install-users","text":"# Add this to your ~/.zshrc or ~/.bashrc export PATH=$PATH:$(go env GOPATH)/bin # Reload your shell source ~/.zshrc # or ~/.bashrc","title":"For Go Install Users"},{"location":"install/#for-homebrew-users","text":"Homebrew automatically configures the PATH, but you may need to start a new terminal session.","title":"For Homebrew Users"},{"location":"install/#usage-modes","text":"","title":"Usage Modes"},{"location":"install/#interactive-shell","text":"The most common usage - start an interactive session: gosh","title":"Interactive Shell"},{"location":"install/#single-command-execution","text":"Execute a single command and exit: gosh -c 'fmt.Println(\"Hello from gosh\")' # Or with shell commands gosh -c 'ls -la' # With Go code gosh -c 'files := $(ls); fmt.Printf(\"Found %d files\\n\", len(strings.Split(files, \"\\n\")))'","title":"Single Command Execution"},{"location":"install/#as-login-shell","text":"Make gosh your default shell: # Add to available shells echo $(which gosh) | sudo tee -a /etc/shells # Set as default shell chsh -s $(which gosh)","title":"As Login Shell"},{"location":"install/#post-installation-setup","text":"","title":"Post-Installation Setup"},{"location":"install/#create-configuration-directory","text":"Set up your gosh configuration: # Create config directory mkdir -p ~/.config/gosh # Initialize with example config gosh gosh> init This creates an example ~/.config/gosh/config.go file with useful functions.","title":"Create Configuration Directory"},{"location":"install/#verify-functions","text":"Test some built-in functions: gosh> gs # Git status helper gosh> build() # Build helper gosh> test() # Test helper","title":"Verify Functions"},{"location":"install/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"install/#common-issues","text":"Command not found: gosh # Check if gosh is in PATH which gosh # If not found, add Go bin directory to PATH export PATH=$PATH:$(go env GOPATH)/bin Permission denied # Make sure gosh is executable chmod +x $(which gosh) Config loading errors # Check config directory permissions ls -la ~/.config/gosh/ # If needed, fix permissions chmod 755 ~/.config/gosh Go not installed # Install Go on macOS brew install go # Or download from https://go.dev/","title":"Common Issues"},{"location":"install/#getting-help","text":"If you encounter issues: Check this troubleshooting section Review the User Guide for configuration help Open an issue on GitHub","title":"Getting Help"},{"location":"install/#upgrade-instructions","text":"","title":"Upgrade Instructions"},{"location":"install/#homebrew-users","text":"brew upgrade rsarv3006/gosh/gosh","title":"Homebrew Users"},{"location":"install/#go-install-users","text":"go install github.com/rsarv3006/gosh@latest","title":"Go Install Users"},{"location":"install/#source-users","text":"cd gosh git pull origin main go build","title":"Source Users"},{"location":"install/#whats-next","text":"Once gosh is installed and working: Getting Started Guide - Learn basic usage Configuration Examples - Set up custom functions User Guide - Advanced features CLI Reference - Complete command documentation Enjoy your enhanced shell experience! \ud83d\ude80","title":"What's Next?"},{"location":"reference/","text":"CLI Reference Complete reference for gosh command-line options, built-in commands, and shellapi functions. Command Line Options gosh Start an interactive gosh session: gosh Options -v, --version - Show version information -h, --help - Show help message -c '<command>' - Execute single command and exit # Show version gosh --version # Show help gosh --help # Execute Go code gosh -c 'fmt.Println(\"Hello world\")' # Execute shell command gosh -c 'ls -la' # Mixed command gosh -c 'files := $(ls); fmt.Printf(\"Found %d files\\n\", len(strings.Split(files, \"\\n\")))' Built-in Commands cd Change to the specified directory. gosh> cd ~/projects gosh> cd /tmp gosh> cd .. # Parent directory gosh> cd ../sibling # Sibling directory pwd Print the current working directory. gosh> pwd /Users/username/projects/gosh exit Exit gosh and return to the previous shell. gosh> exit help Display help information for built-in commands. gosh> help Available built-ins: - cd <path> Change directory - pwd Print working directory - exit Exit gosh - init Create example config - help Show this help init Create an example configuration file at ~/.config/gosh/config.go . gosh> init \u2705 Created example config: ~/.config/gosh/config.go Go REPL Features Variable Assignment gosh> x := 42 gosh> name := \"gosh\" gosh> files := $(ls) Function Definition gosh> func add(a, b int) int { ... return a + b ... } Control Structures gosh> for i := 0; i < 3; i++ { ... fmt.Println(i) ... } gosh> if true { ... fmt.Println(\"it's true\") ... } Import Support Common packages are pre-imported automatically: fmt os strings time filepath io/ioutil encoding/json gosh> fmt.Println(\"Hello\") gosh> os.Getenv(\"HOME\") gosh> strings.Split(\"a,b,c\", \",\") gosh> time.Now() Command Substitution Syntax variable := $(command) Examples # Capture file list files := $(ls) # Capture git status status := $(git status --porcelain) # Capture file count count := $(ls | wc -l) # Use in expressions if $(git status) == \"\" { fmt.Println(\"Working directory is clean\") } # Complex commands timestamp := $(date +%Y%m%d_%H%M%S) backupFile := $(echo $HOME/.ssh/backup_${timestamp}.tar) Shellapi Functions Reference \ud83d\udcc1 File Operations Function Description Purpose Ls() Basic file listing ls LsColor() Colorized file listing ls --color=auto LsSortBySize() Files sorted by size ls -S Tree() Directory tree structure tree Find(pattern) Find files by pattern find . -name pattern Grep(pattern, args...) Search in files grep pattern file Cat(file) Display file contents cat file Head(n, file) First N lines of file head -n file Tail(n, file) Last N lines of file tail -n file Touch(filename) Create/update file timestamp touch filename MakeDir(dir) Create directory mkdir dir RemoveFile(file) Delete file rm file RemoveDir(dir) Delete directory rm -rf dir FileExists(path) Check if file exists test -f IsDirectory(path) Check if path is directory test -d \ud83d\udd27 Git Operations Function Description Purpose GitStatus() Repository status git status GitLog() Recent commits git log --oneline GitBranch() Current branch name git branch --show-current GitDiff() Git diff output git diff GitAdd(files...) Add files to staging git add files GitCommit(msg) Create commit git commit -m msg QuickCommit(msg) Add all and commit git add . && git commit GitPull() Pull latest changes git pull GitPush() Push to remote git push GitStashList() List stashes git stash list GitStashPush(msg) Create stash git stash push -m msg \ud83d\udee0 Development Tools Function Description Purpose GoBuild() Build Go project go build GoRun() Run Go project go run . GoTest() Run tests go test -v GoTestRun() Build and test go test -v -run ./... GoInstall(pkg) Install Go package go install pkg GoFmt() Format Go code go fmt GoGet() Get dependencies go get GoTidy() Clean dependencies go mod tidy GoVet() Run go vet go vet NpmInstall(pkg) Install npm package npm install pkg NpmRun(script) Run npm script npm run script PipInstall(pkg) Install Python package pip install pkg DockerPs() List containers docker ps DockerImages() List images docker images DockerLogs(container) Container logs docker logs container DockerStop(container) Stop container docker stop container DockerRm(container) Remove container docker rm container \ud83d\udcbb System Information Function Description Purpose Uptime() System uptime uptime Whoami() Current user whoami Date() Current date/time date Hostname() System hostname hostname OS() Kernel name uname -s Arch() System architecture uname -m Pwd() Working directory pwd Df() Disk usage df -h Free() Memory usage free -h Ps() Running processes ps aux Kill(pid) Terminate process kill pid \ud83c\udfa8 Formatting & Display Function Description Output Red(str) Red text Text in red Green(str) Green text Text in green Blue(str) Blue text Text in blue Yellow(str) Yellow text Text in yellow Purple(str) Magenta text Text in magenta Cyan(str) Cyan text Text in cyan Bold(str) Bold text Text Underline(str) Underlined text Text Italic(str) Italic text Text Success(str) Green checkmark \u2713 Success Error(str) Red cross mark \u2717 Error Warning(str) Yellow triangle \u26a0 Warning Info(str) Blue info circle \u2139 Info SuccessMsg(label, msg) Success message with label \u2713 Label: Message ErrorMsg(msg) Error message with formatting \u2717 Error message WarnMsg(label, msg) Warning with label \u26a0 Label: Message InfoMsg(label, msg) Info message with label \u2139 Label: Message Color Usage Examples # In config.go func greetUser(name string) { greeting := shellapi.Green(fmt.Sprintf(\"Hello %s!\", name)) fmt.Println(greeting) } func showStatus(msg string) { status := shellapi.InfoMsg(\"Status\", msg) fmt.Println(status) } func reportError(err string) { error := shellapi.ErrorMsg(\"Error\", err) fmt.Println(error) } gosh_lib - Complete Function Library Installation Add gosh_lib to your Go module: go get github.com/rsarv3006/gosh_lib/shellapi Import in Config // ~/.config/gosh/config.go package main import ( \"fmt\" \"github.com/rsarv3006/gosh_lib/shellapi\" ) func init() { fmt.Println(\"\ud83d\ude80 gosh with shellapi loaded!\") } RunShell Function - Core Engine The shellapi.RunShell function executes real shell commands and handles special cases like directory changes: // Basic command execution result, err := shellapi.RunShell(\"command\", \"arg1\", \"arg2\") // Directory changes that persist func goProject() string { result, err := shellapi.RunShell(\"cd\", \"/path/to/project\") if err != nil { return \"CD ERROR: \" + err.Error() } return result // Directory actually changes! } // System commands msg, err := shellapi.RunShell(\"uptime\") files, err := shellapi.RunShell(\"ls\", \"-la\") # Multi-argument commands with spaces result, err := shellapi.RunShell(\"git\", \"commit\", \"-m\", \"Fixed bug in user login\") Directory Change Integration Directory changes work seamlessly with the gosh shell: func navigationExample() string { // This actually changes directories in the shell session! if result, err := shellapi.RunShell(\"cd\", \"/tmp\"); err == nil { return \"Switched to temp directory\" } return \"Failed to change directory\" } // Usage in gosh: // gosh> navigationExample() // Switched to temp directory // gosh> pwd // /tmp # Directory actually changed! Complete Function Categories Project Helpers MakeTarget(target) # Run make target MakeBuild() # make build MakeClean() # make clean MakeTest() # make test RunTests() # Build and test BuildAndTest() # Build and test combined CreateProjectDir(name) # Create project directory TouchFile(filename) # Touch file JoinPaths(parts...) # Join paths safely Basename(path) # Get filename only Dirname(path) # Get directory only ExpandUserHome(path) # Expand ~ to home GetScriptDir() # Get script directory Text Processing Clean(str) # Clean string Trim(str) # Trim whitespace Upper(str) # Uppercase Lower(str) # Lowercase Title(str) # Title case Replace(str, old, new) # Replace text Contains(str, sub) # Check substring HasPrefix(str, prefix) # Check prefix HasSuffix(str, suffix) # Check suffix Environment Variables EnvVar(name) # Get environment variable Getenv(name, fallback) # Env var with fallback ExportEnv(name, value) # Set environment variable UnsetEnv(name) # Unset environment variable ListEnv() # List all environment variables Path Operations PathExists(path) # Check if path exists FileExists(path) # Check if file exists IsFile(path) # Check if path is file IsDir(path) # Check if path is directory Readable(path) # Check if readable Writable(path) # Check if writable Executable(path) # Check if executable FileSize(path) # Get file size FileModTime(path) # Get modification time Error Handling Shellapi Error Handling All shellapi functions return (string, error) tuples: func safeOperation() string { result, err := shellapi.GitStatus() if err != nil { return shellapi.ErrorMsg(\"Git Error\", err.Error()) } return shellapi.SuccessMsg(\"Git Status\", result) } func directoryOperation() string { result, err := shellapi.RunShell(\"cd\", \"/some/path\") if err != nil { return shellapi.ErrorMsg(\"Directory Error\", err.Error()) } return shellapi.SuccessMsg(\"Directory\", \"Changed successfully\") } Go Code Error Handling In the REPL, errors show line numbers: gosh> undefined_function Error: undefined: undefined_function on line 1 gosh> fmt.Println(undefined_var) Error: undefined: undefined_var on line 1 Signal Handling Ctrl+C Behavior Interrupt Go code : Stops current Go execution Interrupt shell commands : Properly terminates subprocesses Preserves session : Continues interactive shell Signal Propagation gosh> # Long-running command gosh> for i := 0; i < 100; i++ { ... fmt.Println(i) ... time.Sleep(1 * time.Second) ... } # Press Ctrl+C to interrupt ^C gosh> # Shell continues running Performance Considerations Command Execution Commands use Go's os/exec for real execution Output is fully captured as strings Large outputs are truncated at 40,000 characters Memory Usage Go state persists across shell session Variables and functions remain defined Use clear() function to reset state (if available) Startup Time Instant startup - no REPL initialization waiting Config file loading is asynchronous Shell session ready immediately Best Practices Use shellapi functions : Pre-built optimized functions Cache expensive operations : Store results of costly commands Handle errors : Always check error returns Use color functions : Better readability Group related functions : Consistent naming patterns Need more examples? Check out our Configuration Examples for real-world configurations!","title":"CLI Reference"},{"location":"reference/#cli-reference","text":"Complete reference for gosh command-line options, built-in commands, and shellapi functions.","title":"CLI Reference"},{"location":"reference/#command-line-options","text":"","title":"Command Line Options"},{"location":"reference/#gosh","text":"Start an interactive gosh session: gosh","title":"gosh"},{"location":"reference/#options","text":"-v, --version - Show version information -h, --help - Show help message -c '<command>' - Execute single command and exit # Show version gosh --version # Show help gosh --help # Execute Go code gosh -c 'fmt.Println(\"Hello world\")' # Execute shell command gosh -c 'ls -la' # Mixed command gosh -c 'files := $(ls); fmt.Printf(\"Found %d files\\n\", len(strings.Split(files, \"\\n\")))'","title":"Options"},{"location":"reference/#built-in-commands","text":"","title":"Built-in Commands"},{"location":"reference/#cd","text":"Change to the specified directory. gosh> cd ~/projects gosh> cd /tmp gosh> cd .. # Parent directory gosh> cd ../sibling # Sibling directory","title":"cd"},{"location":"reference/#pwd","text":"Print the current working directory. gosh> pwd /Users/username/projects/gosh","title":"pwd"},{"location":"reference/#exit","text":"Exit gosh and return to the previous shell. gosh> exit","title":"exit"},{"location":"reference/#help","text":"Display help information for built-in commands. gosh> help Available built-ins: - cd <path> Change directory - pwd Print working directory - exit Exit gosh - init Create example config - help Show this help","title":"help"},{"location":"reference/#init","text":"Create an example configuration file at ~/.config/gosh/config.go . gosh> init \u2705 Created example config: ~/.config/gosh/config.go","title":"init"},{"location":"reference/#go-repl-features","text":"","title":"Go REPL Features"},{"location":"reference/#variable-assignment","text":"gosh> x := 42 gosh> name := \"gosh\" gosh> files := $(ls)","title":"Variable Assignment"},{"location":"reference/#function-definition","text":"gosh> func add(a, b int) int { ... return a + b ... }","title":"Function Definition"},{"location":"reference/#control-structures","text":"gosh> for i := 0; i < 3; i++ { ... fmt.Println(i) ... } gosh> if true { ... fmt.Println(\"it's true\") ... }","title":"Control Structures"},{"location":"reference/#import-support","text":"Common packages are pre-imported automatically: fmt os strings time filepath io/ioutil encoding/json gosh> fmt.Println(\"Hello\") gosh> os.Getenv(\"HOME\") gosh> strings.Split(\"a,b,c\", \",\") gosh> time.Now()","title":"Import Support"},{"location":"reference/#command-substitution","text":"","title":"Command Substitution"},{"location":"reference/#syntax","text":"variable := $(command)","title":"Syntax"},{"location":"reference/#examples","text":"# Capture file list files := $(ls) # Capture git status status := $(git status --porcelain) # Capture file count count := $(ls | wc -l) # Use in expressions if $(git status) == \"\" { fmt.Println(\"Working directory is clean\") } # Complex commands timestamp := $(date +%Y%m%d_%H%M%S) backupFile := $(echo $HOME/.ssh/backup_${timestamp}.tar)","title":"Examples"},{"location":"reference/#shellapi-functions-reference","text":"","title":"Shellapi Functions Reference"},{"location":"reference/#file-operations","text":"Function Description Purpose Ls() Basic file listing ls LsColor() Colorized file listing ls --color=auto LsSortBySize() Files sorted by size ls -S Tree() Directory tree structure tree Find(pattern) Find files by pattern find . -name pattern Grep(pattern, args...) Search in files grep pattern file Cat(file) Display file contents cat file Head(n, file) First N lines of file head -n file Tail(n, file) Last N lines of file tail -n file Touch(filename) Create/update file timestamp touch filename MakeDir(dir) Create directory mkdir dir RemoveFile(file) Delete file rm file RemoveDir(dir) Delete directory rm -rf dir FileExists(path) Check if file exists test -f IsDirectory(path) Check if path is directory test -d","title":"\ud83d\udcc1 File Operations"},{"location":"reference/#git-operations","text":"Function Description Purpose GitStatus() Repository status git status GitLog() Recent commits git log --oneline GitBranch() Current branch name git branch --show-current GitDiff() Git diff output git diff GitAdd(files...) Add files to staging git add files GitCommit(msg) Create commit git commit -m msg QuickCommit(msg) Add all and commit git add . && git commit GitPull() Pull latest changes git pull GitPush() Push to remote git push GitStashList() List stashes git stash list GitStashPush(msg) Create stash git stash push -m msg","title":"\ud83d\udd27 Git Operations"},{"location":"reference/#development-tools","text":"Function Description Purpose GoBuild() Build Go project go build GoRun() Run Go project go run . GoTest() Run tests go test -v GoTestRun() Build and test go test -v -run ./... GoInstall(pkg) Install Go package go install pkg GoFmt() Format Go code go fmt GoGet() Get dependencies go get GoTidy() Clean dependencies go mod tidy GoVet() Run go vet go vet NpmInstall(pkg) Install npm package npm install pkg NpmRun(script) Run npm script npm run script PipInstall(pkg) Install Python package pip install pkg DockerPs() List containers docker ps DockerImages() List images docker images DockerLogs(container) Container logs docker logs container DockerStop(container) Stop container docker stop container DockerRm(container) Remove container docker rm container","title":"\ud83d\udee0 Development Tools"},{"location":"reference/#system-information","text":"Function Description Purpose Uptime() System uptime uptime Whoami() Current user whoami Date() Current date/time date Hostname() System hostname hostname OS() Kernel name uname -s Arch() System architecture uname -m Pwd() Working directory pwd Df() Disk usage df -h Free() Memory usage free -h Ps() Running processes ps aux Kill(pid) Terminate process kill pid","title":"\ud83d\udcbb System Information"},{"location":"reference/#formatting-display","text":"Function Description Output Red(str) Red text Text in red Green(str) Green text Text in green Blue(str) Blue text Text in blue Yellow(str) Yellow text Text in yellow Purple(str) Magenta text Text in magenta Cyan(str) Cyan text Text in cyan Bold(str) Bold text Text Underline(str) Underlined text Text Italic(str) Italic text Text Success(str) Green checkmark \u2713 Success Error(str) Red cross mark \u2717 Error Warning(str) Yellow triangle \u26a0 Warning Info(str) Blue info circle \u2139 Info SuccessMsg(label, msg) Success message with label \u2713 Label: Message ErrorMsg(msg) Error message with formatting \u2717 Error message WarnMsg(label, msg) Warning with label \u26a0 Label: Message InfoMsg(label, msg) Info message with label \u2139 Label: Message","title":"\ud83c\udfa8 Formatting &amp; Display"},{"location":"reference/#color-usage-examples","text":"# In config.go func greetUser(name string) { greeting := shellapi.Green(fmt.Sprintf(\"Hello %s!\", name)) fmt.Println(greeting) } func showStatus(msg string) { status := shellapi.InfoMsg(\"Status\", msg) fmt.Println(status) } func reportError(err string) { error := shellapi.ErrorMsg(\"Error\", err) fmt.Println(error) }","title":"Color Usage Examples"},{"location":"reference/#gosh_lib-complete-function-library","text":"","title":"gosh_lib - Complete Function Library"},{"location":"reference/#installation","text":"Add gosh_lib to your Go module: go get github.com/rsarv3006/gosh_lib/shellapi","title":"Installation"},{"location":"reference/#import-in-config","text":"// ~/.config/gosh/config.go package main import ( \"fmt\" \"github.com/rsarv3006/gosh_lib/shellapi\" ) func init() { fmt.Println(\"\ud83d\ude80 gosh with shellapi loaded!\") }","title":"Import in Config"},{"location":"reference/#runshell-function-core-engine","text":"The shellapi.RunShell function executes real shell commands and handles special cases like directory changes: // Basic command execution result, err := shellapi.RunShell(\"command\", \"arg1\", \"arg2\") // Directory changes that persist func goProject() string { result, err := shellapi.RunShell(\"cd\", \"/path/to/project\") if err != nil { return \"CD ERROR: \" + err.Error() } return result // Directory actually changes! } // System commands msg, err := shellapi.RunShell(\"uptime\") files, err := shellapi.RunShell(\"ls\", \"-la\") # Multi-argument commands with spaces result, err := shellapi.RunShell(\"git\", \"commit\", \"-m\", \"Fixed bug in user login\")","title":"RunShell Function - Core Engine"},{"location":"reference/#directory-change-integration","text":"Directory changes work seamlessly with the gosh shell: func navigationExample() string { // This actually changes directories in the shell session! if result, err := shellapi.RunShell(\"cd\", \"/tmp\"); err == nil { return \"Switched to temp directory\" } return \"Failed to change directory\" } // Usage in gosh: // gosh> navigationExample() // Switched to temp directory // gosh> pwd // /tmp # Directory actually changed!","title":"Directory Change Integration"},{"location":"reference/#complete-function-categories","text":"","title":"Complete Function Categories"},{"location":"reference/#project-helpers","text":"MakeTarget(target) # Run make target MakeBuild() # make build MakeClean() # make clean MakeTest() # make test RunTests() # Build and test BuildAndTest() # Build and test combined CreateProjectDir(name) # Create project directory TouchFile(filename) # Touch file JoinPaths(parts...) # Join paths safely Basename(path) # Get filename only Dirname(path) # Get directory only ExpandUserHome(path) # Expand ~ to home GetScriptDir() # Get script directory","title":"Project Helpers"},{"location":"reference/#text-processing","text":"Clean(str) # Clean string Trim(str) # Trim whitespace Upper(str) # Uppercase Lower(str) # Lowercase Title(str) # Title case Replace(str, old, new) # Replace text Contains(str, sub) # Check substring HasPrefix(str, prefix) # Check prefix HasSuffix(str, suffix) # Check suffix","title":"Text Processing"},{"location":"reference/#environment-variables","text":"EnvVar(name) # Get environment variable Getenv(name, fallback) # Env var with fallback ExportEnv(name, value) # Set environment variable UnsetEnv(name) # Unset environment variable ListEnv() # List all environment variables","title":"Environment Variables"},{"location":"reference/#path-operations","text":"PathExists(path) # Check if path exists FileExists(path) # Check if file exists IsFile(path) # Check if path is file IsDir(path) # Check if path is directory Readable(path) # Check if readable Writable(path) # Check if writable Executable(path) # Check if executable FileSize(path) # Get file size FileModTime(path) # Get modification time","title":"Path Operations"},{"location":"reference/#error-handling","text":"","title":"Error Handling"},{"location":"reference/#shellapi-error-handling","text":"All shellapi functions return (string, error) tuples: func safeOperation() string { result, err := shellapi.GitStatus() if err != nil { return shellapi.ErrorMsg(\"Git Error\", err.Error()) } return shellapi.SuccessMsg(\"Git Status\", result) } func directoryOperation() string { result, err := shellapi.RunShell(\"cd\", \"/some/path\") if err != nil { return shellapi.ErrorMsg(\"Directory Error\", err.Error()) } return shellapi.SuccessMsg(\"Directory\", \"Changed successfully\") }","title":"Shellapi Error Handling"},{"location":"reference/#go-code-error-handling","text":"In the REPL, errors show line numbers: gosh> undefined_function Error: undefined: undefined_function on line 1 gosh> fmt.Println(undefined_var) Error: undefined: undefined_var on line 1","title":"Go Code Error Handling"},{"location":"reference/#signal-handling","text":"","title":"Signal Handling"},{"location":"reference/#ctrlc-behavior","text":"Interrupt Go code : Stops current Go execution Interrupt shell commands : Properly terminates subprocesses Preserves session : Continues interactive shell","title":"Ctrl+C Behavior"},{"location":"reference/#signal-propagation","text":"gosh> # Long-running command gosh> for i := 0; i < 100; i++ { ... fmt.Println(i) ... time.Sleep(1 * time.Second) ... } # Press Ctrl+C to interrupt ^C gosh> # Shell continues running","title":"Signal Propagation"},{"location":"reference/#performance-considerations","text":"","title":"Performance Considerations"},{"location":"reference/#command-execution","text":"Commands use Go's os/exec for real execution Output is fully captured as strings Large outputs are truncated at 40,000 characters","title":"Command Execution"},{"location":"reference/#memory-usage","text":"Go state persists across shell session Variables and functions remain defined Use clear() function to reset state (if available)","title":"Memory Usage"},{"location":"reference/#startup-time","text":"Instant startup - no REPL initialization waiting Config file loading is asynchronous Shell session ready immediately","title":"Startup Time"},{"location":"reference/#best-practices","text":"Use shellapi functions : Pre-built optimized functions Cache expensive operations : Store results of costly commands Handle errors : Always check error returns Use color functions : Better readability Group related functions : Consistent naming patterns Need more examples? Check out our Configuration Examples for real-world configurations!","title":"Best Practices"}]}